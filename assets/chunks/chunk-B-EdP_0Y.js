import{T as l,R as f,gY as y,H as c,eO as S,h4 as s,h3 as R,J as g,m5 as d,h0 as J,m6 as O}from"./chunk-XGpVqsM_.js";import"./chunk-DyqHK6XP.js";import"./chunk-Dix477Sg.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-CrMA_peF.js";function x(r){const i=r.geometry,e=r.toJSON(),t=e;let m,o,n;if(i!=null&&(o=i.spatialReference,n=s(o),t.geometryType=R(i),t.geometry=JSON.stringify(i),t.inSR=n),e.outSR?(t.outSR=s(e.outSR),m=r.outSpatialReference):i&&(t.outSR=t.inSR,m=o),t.bin&&=JSON.stringify(t.bin),t.quantizationParameters&&=JSON.stringify(t.quantizationParameters),t.outStatistics&&=JSON.stringify(t.outStatistics),t.outTimeReference&&=JSON.stringify(t.outTimeReference),e.timeExtent){const p=e.timeExtent,{start:a,end:u}=p;a==null&&u==null||(t.time=a===u?a:`${a??"null"},${u??"null"}`),delete e.timeExtent}return r.defaultSpatialReference&&g(o,m)&&(t.defaultSR=t.inSR,delete t.inSR,delete t.outSR),t}async function N(r,i,e){return i.timeExtent!=null&&i.timeExtent.isEmpty?{data:{features:[]}}:await q(r,i,e)}async function q(r,i,e={}){const t=typeof r=="string"?l(r):r,m=i.geometry?[i.geometry]:[],o=await f(m,null,{signal:e.signal}),n=o?.[0];n!=null&&((i=i.clone()).geometry=n);const p=y({...t.query,f:"json",...x(i)});return c(S(t.path,"queryBins"),{...e,query:{...p,...e.query}})}async function st(r,i,e){const{data:t}=await N(J(r),d.from(i),e);return O.fromJSON(t)}export{st as executeAttributeBinsQuery};
