import{hd as M,he as d,hf as v,y as u,hg as C,fl as I,hh as h,hi as x,hj as k,hk as O,hl as S,at as N}from"./chunk-DadqOv6U.js";import P from"./chunk-BkdC799f.js";import"./chunk-CPKck_yD.js";const T=m=>{if(!m)return[0,0,0,0];const{r:e,g:r,b:t,a:s}=m;return[e,r,t,255*s]};class a{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let s=!1;for(const i of t)if(i.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const i of r)i.primitiveName===e.primitiveName&&t.push(i)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)a.findApplicableOverrides(s,r,t);if(e.symbolLayers)for(const s of e.symbolLayers)a.findApplicableOverrides(s,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)a.findApplicableOverrides(s,r,t);if(e.markerPlacement&&a.findApplicableOverrides(e.markerPlacement,r,t),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const s of e.markerGraphics)a.findApplicableOverrides(s,r,t),a.findApplicableOverrides(s.symbol,r,t)}else e.type==="CIMCharacterMarker"?a.findApplicableOverrides(e.symbol,r,t):e.type==="CIMHatchFill"?a.findApplicableOverrides(e.lineSymbol,r,t):e.type==="CIMPictureMarker"&&a.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&M(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=d(e),s=e.primitiveName,i=[];for(const o of r)o.primitiveName===s&&i.push(d(o));return{type:"cim-effect-param",effect:t,overrides:v(i)}}static async resolveSymbolOverrides(e,r,t,s,i,o,c){if(!e?.symbol)return null;let{symbol:l,primitiveOverrides:n}=e;const f=!!n;if(!f&&!s)return l;l=u(l),n=u(n);let y=!0;if(r||(r={attributes:{}},y=!1),f){if(y||(n=n.filter((p=>!p.valueExpressionInfo?.expression.includes("$feature")))),c||(n=n.filter((p=>!p.valueExpressionInfo?.expression.includes("$view")))),n.length>0){const p=C(r.attributes),b={spatialReference:t,fields:p,geometryType:i};await a.createRenderExpressions(n,b),a.evaluateOverrides(n,r,i??"esriGeometryPoint",o,c,new I(p))}a.applyOverrides(l,n)}return s&&a.applyDictionaryTextOverrides(l,r,s,null),l}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const t=[];for(const s of e){const i=s.valueExpressionInfo;if(!i||a._expressionToRenderExpression.has(i.expression))continue;const o=h(i.expression,r.spatialReference);t.push(o),o.then((c=>a._expressionToRenderExpression.set(i.expression,c)))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,r,t,s,i,o){const c={$view:{scale:i?.scale}};for(const l of e){l.value&&typeof l.value=="object"&&x(l.value)&&(l.propertyName==="Color"||l.propertyName==="StrokeColor")&&(l.value=T(l.value));const n=l.valueExpressionInfo;if(!n)continue;const f=a._expressionToRenderExpression.get(n.expression);f&&(l.value=P(f,r,c,t,o,s))}}static applyDictionaryTextOverrides(e,r,t,s,i="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const c of o)c&&c.type==="CIMVectorMarker"&&a.applyDictionaryTextOverrides(c,r,t,s,e.type==="CIMTextSymbol"?e.textCase:i)}break;case"CIMVectorMarker":{const o=e.markerGraphics;if(!o)return;for(const c of o)c&&a.applyDictionaryTextOverrides(c,r,t,s)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const c=k(o,t);e.textString=O(r,c,s,i)}}}}static applyOverrides(e,r,t,s){if(e.primitiveName){for(const i of r)if(i.primitiveName===e.primitiveName){const o=S(i.propertyName);if(s&&s.push({cim:e,nocapPropertyName:o,value:e[o]}),t){let c=!1;for(const l of t)l.primitiveName===e.primitiveName&&(c=!0);c||t.push(i)}i.value!=null&&(e[o]=i.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)a.applyOverrides(i,r,t,s);if(e.symbolLayers)for(const i of e.symbolLayers)a.applyOverrides(i,r,t,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const i of e.effects)a.applyOverrides(i,r,t,s);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const i of e.markerGraphics)a.applyOverrides(i,r,t,s),a.applyOverrides(i.symbol,r,t,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)t.value!==void 0&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map((t=>Number(t)));if(e==="Color"){const t=new N(r).toRgba();return t[3]*=255,t}return r}}export{a as OverrideHelper};
