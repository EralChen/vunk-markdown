import{lX as p,A as D,hp as R,lY as A,lZ as b}from"./chunk-XGpVqsM_.js";const z=15.5,x=4,L=64,j=1024,B={outlineWidth:.75,referenceWidth:.75,cap:p.CIMSolidStroke.capstyle,join:p.CIMSolidStroke.joinstyle,miterLimit:p.CIMSolidStroke.miterlimit},I=()=>D.getLogger("esri.symbols.cim.rasterizingUtils"),U=32,P=t=>t==="vertical"||t==="horizontal"||t==="cross"||t==="esriSFSCross"||t==="esriSFSVertical"||t==="esriSFSHorizontal";function H(t,s,a){const n=s.style,r=A(Math.ceil(a)),o=P(n)?8*r:16*r,e=2*r;t.width=o,t.height=o;const i=t.getContext("2d");i.strokeStyle="#ffffff",i.lineWidth=r,i.beginPath(),n!=="vertical"&&n!=="cross"&&n!=="esriSFSCross"&&n!=="esriSFSVertical"||(i.moveTo(o/2,-e),i.lineTo(o/2,o+e)),n!=="horizontal"&&n!=="cross"&&n!=="esriSFSCross"&&n!=="esriSFSHorizontal"||(i.moveTo(-e,o/2),i.lineTo(o+e,o/2)),n!=="backward-diagonal"&&n!=="diagonal-cross"&&n!=="esriSFSDiagonalCross"&&n!=="esriSFSBackwardDiagonal"||(i.moveTo(-e,-e),i.lineTo(o+e,o+e),i.moveTo(o-e,-e),i.lineTo(o+e,e),i.moveTo(-e,o-e),i.lineTo(e,o+e)),n!=="forward-diagonal"&&n!=="diagonal-cross"&&n!=="esriSFSForwardDiagonal"&&n!=="esriSFSDiagonalCross"||(i.moveTo(o+e,-e),i.lineTo(-e,o+e),i.moveTo(e,-e),i.lineTo(-e,e),i.moveTo(o+e,o-e),i.lineTo(o-e,o+e)),i.stroke();const h=i.getImageData(0,0,t.width,t.height),l=new Uint8Array(h.data);let f;for(let c=0;c<l.length;c+=4)f=l[c+3]/255,l[c]=l[c]*f,l[c+1]=l[c+1]*f,l[c+2]=l[c+2]*f;return[l,t.width,t.height,r]}function V(t){t.length%2==1&&(t=[...t,...t]);const s=t.reduce(((c,m)=>c+m),0),a=Math.round(s*x),n=1,r=new Float32Array(a*n);let o=0,e=0,i=.5,h=!0;for(const c of t){for(o=e,e+=c*x;i<=e;){const m=i-.5,u=Math.min(Math.abs(i-o),Math.abs(i-e));r[m]=h?-u:u,i++}h=!h}const l=r.length,f=new Uint8Array(4*l);for(let c=0;c<l;++c){const m=r[c]/x;R(m/L*.5+.5,f,4*c)}return[f,a,n]}function O(t,s){t==null&&(t=[]);const a=s==="Butt",n=s==="Square",r=!a&&!n;t.length%2==1&&(t=[...t,...t]);const o=z,e=2*o;let i=0;for(const g of t)i+=g;const h=Math.round(i*o),l=new Float32Array(h*e),f=.5*o;let c=0,m=0,u=.5,S=!0;for(const g of t){for(c=m,m+=g*o;u<=m;){let C=.5;for(;C<e;){const $=(C-.5)*h+u-.5,d=r?(C-o)*(C-o):Math.abs(C-o);l[$]=S?a?Math.max(Math.max(c+f-u,d),Math.max(u-m+f,d)):d:r?Math.min((u-c)*(u-c)+d,(u-m)*(u-m)+d):n?Math.min(Math.max(u-c,d),Math.max(m-u,d)):Math.min(Math.max(u-c+f,d),Math.max(m+f-u,d)),C++}u++}S=!S}const T=l.length,v=new Uint8Array(4*T);for(let g=0;g<T;++g){const C=(r?Math.sqrt(l[g]):l[g])/o;R(C,v,4*g)}return[v,h,e]}function X(t,s){const{colorRamp:a,gradientType:n}=s,r=a.type==="CIMFixedColorRamp",o=s.interval||p.CIMGradientFill.interval;let e=w(a);return r&&(e=N(e,o)),n==="Discrete"||r?E(t,e,o):q(t,e)}let y;function Y(t,s){const{colorRamp:a,gradientType:n}=s,r=w(a),o=a.type==="CIMFixedColorRamp";if(n==="Continuous"&&!o)return M(t,r);const e=s.interval??p.CIMGradientFill.interval;if(o)return M(t,N(r,e));const i=[];y??=document.createElement("canvas"),F(y,r,e,1,0);const h=y.getContext("2d").getImageData(0,0,e,1).data;for(let l=0,f=0;l<e;l++,f=4*l){const c=[h[f+0],h[f+1],h[f+2],h[f+3]];i.push({offset:l/e,color:c}),i.push({offset:(l+1)/e,color:c})}return M(t,i)}function w(t){const s=[];switch(t.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{t.type==="CIMPolarContinuousColorRamp"&&I().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const a=t;s.push({offset:0,color:[a.fromColor[0],a.fromColor[1],a.fromColor[2],a.fromColor[3]/255]}),s.push({offset:1,color:[a.toColor[0],a.toColor[1],a.toColor[2],a.toColor[3]/255]});break}case"CIMFixedColorRamp":{const a=t,n=1/(a.colors.length-1);let r=0;for(const o of a.colors)s.push({offset:r,color:[o[0],o[1],o[2],o[3]/255]}),r+=n;break}case"CIMMultipartColorRamp":{const a=t,n=a.weights.reduce(((o,e)=>o+e),0);let r=0;for(let o=0;o<a.colorRamps.length;o++){const e=a.colorRamps[o],i=a.weights[o],h=w(e);for(const l of h)s.push({offset:(r+l.offset*i)/n,color:l.color});r+=i}break}default:I().error(`Color ramp "${t.type}" currently unsupported.`)}return s}function N(t,s){const a=[],n=(t.length-1)/(s-1);for(let r=0;r<s;r++){const o=t[Math.round(r*n)].color;a.push({offset:r/s,color:o}),a.push({offset:(r+1)/s,color:o})}return a}function q(t,s){return F(t,s,U,1,b),k(t)}function E(t,s,a){return F(t,s,a,1,b),k(t)}function M(t,s,a=0){for(const{offset:n,color:r}of s)t.addColorStop(Math.min(Math.max(n,a),1-a),`rgba(${r[0]}, ${r[1]}, ${r[2]}, ${r[3]})`)}function F(t,s,a,n,r){const o=a+2*r;t.width=o,t.height=n;const e=(r+1)/o,i=t.getContext("2d",{willReadFrequently:!0});if(s.length>0){const h=i.createLinearGradient(0,0,o,n);M(h,s,e),i.fillStyle=h}else i.fillStyle="rgba(128, 128, 128, 1)";i.fillRect(0,0,o,n)}function k(t){const{width:s,height:a}=t,n=t.getContext("2d").getImageData(0,0,s,a),r=new Uint8Array(n.data);for(let o=0;o<r.length;o+=4){const e=r[o+3]/255;r[o]*=e,r[o+1]*=e,r[o+2]*=e}return[r,s,a]}function G(t){const s=t[0]?.[0]?.[0]??0,a=t[0]?.[0]?.[1]??0,n={ymin:a,xmin:s,ymax:a,xmax:s,width:0,height:0};for(let r=0;r<t.length;r++){const o=t[r];for(let e=0;e<o.length;e++){const i=o[e][0],h=o[e][1];i<n.xmin&&(n.xmin=i),i>n.xmax&&(n.xmax=i),h<n.ymin&&(n.ymin=h),h>n.ymax&&(n.ymax=h)}}return n.width=Math.abs(n.xmax-n.xmin),n.height=Math.abs(n.ymax-n.ymin),n}function Z(t,s){const a=G(t),n=a.width===0?1:a.width,r=a.height===0?1:a.height,o=[];for(let e=0;e<t.length;e++){const i=t[e],h=[];for(let l=0;l<i.length;l++){let f=Math.round(i[l][0]-a.xmin),c=Math.round(i[l][1]-a.ymin);if(f=s.xmin+f*s.width/n,c=s.ymin+c*s.height/r,isNaN(f)||isNaN(c))throw new Error("Scaled shape has NaN values");h.push([f,c])}o.push(h)}return o}function J(t,s,a){const n=[];for(let r=0;r<t.length;r++){const o=t[r],e=[];for(let i=0;i<o.length;i++){const h=o[i][0]+s,l=o[i][1]+a;if(isNaN(h)||isNaN(l))throw new Error("Scaled shape has NaN values");e.push([h,l])}n.push(e)}return n}export{J as R,Z as T,H as f,X as g,x as i,B as l,V as m,L as o,Y as p,j as r,O as u};
