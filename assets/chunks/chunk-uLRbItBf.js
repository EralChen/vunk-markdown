import{lq as v,bx as b,lr as l,j2 as _,d0 as h,ls as f,lt as x,bh as a,F as y,lu as L,lv as $,lw as C,lx as m,ar as j,au as P}from"./chunk-Bj5pIyxE.js";import{m as S}from"./chunk-CZi-7s83.js";import"./chunk-C39j8-it.js";import"./chunk-DJw_0V8B.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-SqlbPPT2.js";import"./chunk-X-HXysiy.js";const I=1e3;function V(t,o,i){const s=v(),n=l(s);return b(n,n,t,.5),b(n,n,o,.5),s[3]=_(n,t),h(n,n,i),s}let g=class{constructor(){this._idToComponent=new Map,this._components=new f(t=>t.bounds),this._edges=new f(t=>t.bounds),this._tmpLineSegment=x(),this._tmpP1=a(),this._tmpP2=a(),this._tmpP3=a(),this.remoteClient=null}async fetchCandidates(t,o){await Promise.resolve(),y(o),await this._ensureEdgeLocations(t,o);const i=[];return this._edges.forEachNeighbor(s=>(this._addCandidates(t,s,i),i.length<I),t.bounds),{result:{candidates:i}}}async _ensureEdgeLocations(t,o){const i=[];if(this._components.forEachNeighbor(e=>{if(e.info==null){const{id:c,uid:r}=e;i.push({id:c,uid:r})}return!0},t.bounds),!i.length)return;const s={components:i},n=await this.remoteClient.invoke("fetchAllEdgeLocations",s,o??{});for(const e of n.components)this._setFetchEdgeLocations(e)}async add(t){const o=new u(t.id,t.bounds);return this._idToComponent.set(o.id,o),this._components.add([o]),{result:{}}}async remove(t){const o=this._idToComponent.get(t.id);if(o){const i=[];this._edges.forEachNeighbor(s=>(s.component===o&&i.push(s),!0),o.bounds),this._edges.remove(i),this._components.remove([o]),this._idToComponent.delete(o.id)}return{result:{}}}_setFetchEdgeLocations(t){const o=this._idToComponent.get(t.id);if(o==null||t.uid!==o.uid)return;const i=S.createView(t.locations),s=new Array(i.count),n=a(),e=a();for(let d=0;d<i.count;d++){i.position0.getVec(d,n),i.position1.getVec(d,e);const p=V(n,e,t.origin),E=new T(o,d,p);s[d]=E}this._edges.add(s);const{objectIds:c,origin:r}=t;o.info={locations:i,objectIds:c,origin:r}}_addCandidates(t,o,i){const{info:s}=o.component,{origin:n,objectIds:e}=s,c=s.locations,r=c.position0.getVec(o.index,this._tmpP1),d=c.position1.getVec(o.index,this._tmpP2);h(r,r,n),h(d,d,n);const p=e[c.componentIndex.get(o.index)];this._addEdgeCandidate(t,p,r,d,i),w(t,p,r,i),w(t,p,d,i)}_addEdgeCandidate(t,o,i,s,n){if(!t.returnEdge)return;const e=l(t.bounds),c=L(i,s,this._tmpLineSegment),r=$(c,e,this._tmpP3);C(t.bounds,r)&&n.push({type:"edge",objectId:o,target:m(r),distance:_(e,r),start:m(i),end:m(s)})}};g=j([P("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],g);const Et=g;function w(t,o,i,s){if(!t.returnVertex||!C(t.bounds,i))return;const n=l(t.bounds);s.push({type:"vertex",objectId:o,target:m(i),distance:_(n,i)})}class u{constructor(o,i){this.id=o,this.bounds=i,this.info=null,this.uid=++u.uid}}u.uid=0;class T{constructor(o,i,s){this.component=o,this.index=i,this.bounds=s}}export{Et as default};
