import{b9 as p,cE as y,cF as h}from"./chunk-mH00GGPN.js";import"./chunk-Crt2IEHJ.js";import"./chunk-D3Fu2eSY.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-SqlbPPT2.js";function a(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function l(e){return e&&(Array.isArray(e)?e.map(l):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>y(t)):y(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function n(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:l(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:l(t)}))}function oe(e){return n("extendedSpatialReferenceInfo",[e])}async function ce(e,t){return o(await n("clip",[a(e),e,t]))}async function se(e,t){return o(await n("cut",[a(e),e,t]))}function ue(e,t){return n("contains",[a(e),e,t])}function fe(e,t){return n("crosses",[a(e),e,t])}function pe(e,t,r){return n("distance",[a(e),e,t,r])}function le(e,t){return n("equals",[a(e),e,t])}function me(e,t){return n("intersects",[a(e),e,t])}function ye(e,t){return n("touches",[a(e),e,t])}function we(e,t){return n("within",[a(e),e,t])}function de(e,t){return n("disjoint",[a(e),e,t])}function ge(e,t){return n("overlaps",[a(e),e,t])}function he(e,t,r){return n("relate",[a(e),e,t,r])}function Se(e){return n("isSimple",[a(e),e])}async function xe(e){return o(await n("simplify",[a(e),e]))}async function Re(e,t=!1){return o(await n("convexHull",[a(e),e,t]))}async function Ae(e,t){return o(await n("difference",[a(e),e,t]))}async function Oe(e,t){return o(await n("symmetricDifference",[a(e),e,t]))}async function De(e,t){return o(await n("intersect",[a(e),e,t]))}async function Je(e,t=null){const r=S(e,t);return o(await n("union",[a(r),r]))}async function Ne(e,t,r,i,c,u){return o(await n("offset",[a(e),e,t,r,i,c,u]))}async function Ee(e,t,r,i=!1){const c=[a(e),e,t,r,i];return o(await n("buffer",c))}async function Le(e,t,r,i,c,u){const g=[a(e),e,t,r,i,c,u];return o(await n("geodesicBuffer",g))}async function Te(e,t,r=!0){const i=await n("nearestCoordinate",[a(e),e,t,r]);return{...i,coordinate:p.fromJSON(i.coordinate)}}async function Ve(e,t){const r=await n("nearestVertex",[a(e),e,t]);return{...r,coordinate:p.fromJSON(r.coordinate)}}async function be(e,t,r,i){return(await n("nearestVertices",[a(e),e,t,r,i])).map(c=>({...c,coordinate:p.fromJSON(c.coordinate)}))}function m(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function ve(e,t,r){if(e==null)throw new s;const i=e.spatialReference;if((r=r??m(e))==null)throw new s;const c=e.constructor.fromJSON(await n("rotate",[i,e,t,r]));return c.spatialReference=i,c}async function ze(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await n("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function He(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await n("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function je(e,t,r,i){return o(await n("generalize",[a(e),e,t,r,i]))}async function Ie(e,t,r){return o(await n("densify",[a(e),e,t,r]))}async function Pe(e,t,r,i=0){return o(await n("geodesicDensify",[a(e),e,t,r,i]))}function ke(e,t){return n("planarArea",[a(e),e,t])}function qe(e,t){return n("planarLength",[a(e),e,t])}function Be(e,t,r){return n("geodesicArea",[a(e),e,t,r])}function Ce(e,t,r){return n("geodesicLength",[a(e),e,t,r])}async function Ge(e,t){return o(await n("intersectLinesToPoints",[a(e),e,t]))}async function $e(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function Fe(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class s extends Error{constructor(){super("Illegal Argument Exception")}}export{Ee as buffer,$e as changeDefaultSpatialReferenceTolerance,Fe as clearDefaultSpatialReferenceTolerance,ce as clip,ue as contains,Re as convexHull,fe as crosses,se as cut,Ie as densify,Ae as difference,de as disjoint,pe as distance,le as equals,oe as extendedSpatialReferenceInfo,ze as flipHorizontal,He as flipVertical,je as generalize,Be as geodesicArea,Le as geodesicBuffer,Pe as geodesicDensify,Ce as geodesicLength,De as intersect,Ge as intersectLinesToPoints,me as intersects,Se as isSimple,Te as nearestCoordinate,Ve as nearestVertex,be as nearestVertices,Ne as offset,ge as overlaps,ke as planarArea,qe as planarLength,he as relate,ve as rotate,xe as simplify,Oe as symmetricDifference,ye as touches,Je as union,we as within};
