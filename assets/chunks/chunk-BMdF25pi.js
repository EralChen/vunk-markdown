import{j as e,s}from"./chunk-CuaFhuP3.js";import{W as m}from"./chunk-Dpk1TJd9.js";import{p as n}from"./chunk-b-Uii-I4.js";import{B as a}from"./chunk-Btn-XPY7.js";import"./chunk-iOPJXyP1.js";import"./chunk-DGmg3LSc.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-Cj6q1fp6.js";import"./chunk-BIcMZiQX.js";async function rr(r,t,o){await Promise.resolve(),e(o);const i=a(r,t,{useEllipsoid:o?.useEllipsoid});if(!i)throw new s("meshUtils:convertVertexSpace()","Failed to convert to provided vertex space due to projection errors");const p=r.cloneAndModifyVertexAttributes(new n({...i,uv:m(r.vertexAttributes.uv),color:m(r.vertexAttributes.color)}),t);return p.transform=null,p}export{rr as convertMeshVertexSpace};
