import{a3 as v,S as M}from"./chunk-Dpk1TJd9.js";import{bx as c,im as d,ba as g,io as h,ip as y,iq as I,ir as w,is as S}from"./chunk-CuaFhuP3.js";import{u as x,c as l,i as $,f as F}from"./chunk-C0RqjT89.js";import"./chunk-iOPJXyP1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DGmg3LSc.js";import"./chunk-DpG3zF1g.js";class O{transform(t){const r=this._transform(t),o=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&o.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&v(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&o.push(n.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(t){const r=x(t.schema,t.geometryBuffer);let o=r.length/3,n=null;const f=new Array,a=l(t.primaryAttributeData,r,o);t.primaryAttributeData!=null&&a&&f.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:a});const s=l(t.modulationAttributeData,r,o);t.modulationAttributeData!=null&&s&&f.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:s});let i=$(t.rendererInfo,a,s,o);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const u=t.filterAttributesData.filter(M).map((e=>{const D=l(e,r,o),b={attributeInfo:e.attributeInfo,values:D};return f.push(b),b}));n=new Uint32Array(o),o=F(r,i,n,t.filterInfo,u)}for(const u of t.userAttributesData){const e=l(u,r,o);f.push({attributeInfo:u.attributeInfo,values:e})}3*o<i.length&&(i=new Uint8Array(i.buffer.slice(0,3*o))),z(r,o,t.elevationOffset);const p=q(r,o,d.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:p,rgb:i,attributes:f,pointIdFilterMap:n}}}function q(m,t,r,o,n){if(!g(m,o,0,m,n,0,t))throw new Error("Can't reproject");const f=h(r.center),a=I(),s=I(),i=h(r.halfSize);y(A,r.quaternion);const p=new Float32Array(3*t);for(let u=0;u<t;u++){let e=3*u;a[0]=m[e]-f[0],a[1]=m[e+1]-f[1],a[2]=m[e+2]-f[2],w(s,a,A),i[0]=Math.max(i[0],Math.abs(s[0])),i[1]=Math.max(i[1],Math.abs(s[1])),i[2]=Math.max(i[2],Math.abs(s[2])),p[e++]=a[0],p[e++]=a[1],p[e]=a[2]}return r.halfSize=i,p}function z(m,t,r){if(r!==0)for(let o=0;o<t;o++)m[3*o+2]+=r}const A=S();function Mt(){return new O}export{Mt as default};
