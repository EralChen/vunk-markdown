import{iD as d,iE as S}from"./chunk-CuaFhuP3.js";import{P,j as E,a as y,f as G,x as T}from"./chunk-BUVSeX7E.js";import{w as v}from"./chunk-D2mMIPZM.js";import{H as w,K as C,b as D,m as q,A as X,T as A,q as L,Z as Y,C as b,D as j}from"./chunk-A9ItisFv.js";import"./chunk-Dpk1TJd9.js";import"./chunk-iOPJXyP1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DGmg3LSc.js";import"./chunk-Da9IW-EP.js";import"./chunk-RvJNgVq9.js";import"./chunk-B92kdZ15.js";import"./chunk-DP7_WWTp.js";class Xt{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,r,s){return!1}canAccelerateGeometry(e){return!1}execute(e,r,s,n){if(s===4)return new v().execute(e,r,n);if(r.getCoordinateSystemType()===0&&P(""),E(e),e.isEmpty()||e.getDimension()<1)return 0;const m=r.getGCS(),o=w();m.querySpheroidData(o);const p=o.majorSemiAxis,l=o.e2,c=m.getUnit().getUnitToBaseFactor();let t;const i=e.getGeometryType();if(i===y.enumPolygon?t=e.getBoundary():i===y.enumEnvelope?t=C(e):G(i)?(t=new D({vd:e.getDescription()}),t.addSegment(e,!0)):t=e,t.hasNonLinearSegments()&&(t=new q().execute(t,0,r.getTolerance(0),0,n)),m!==r){const a=r.getSRToGCSTransform();if(r.isPannable()){t=X(t,r),i===y.enumPolyline&&t===e&&(t=e.clone());const h=new T;r.getPannableExtent().queryIntervalX(h);for(let u=0,x=t.getPointCount();u<x;u++){const g=t.getXY(u);g.x=A(g.x,h),t.setXY(u,g)}}const f=t.createInstance();t=Y(a,t,f,n)?f:new L().execute(t,a,n)}return this._ExecuteMultiPathGeodeticLength(t,s,p,l,c)}_ExecuteMultiPathGeodeticLength(e,r,s,n,m){const o={stack:[],error:void 0,hasError:!1};try{const p=d(o,new b,!1);let l=0;const c=e.querySegmentIterator();for(;c.nextPath();)for(;c.hasNextSegment();){const t=c.nextSegment(),i=t.getStartXY(),a=t.getEndXY();i.scale(m),a.scale(m),j.geodeticDistance(s,n,i.x,i.y,a.x,a.y,p,null,null,r),l+=p.val}return l}catch(p){o.error=p,o.hasError=!0}finally{S(o)}}}export{Xt as OperatorGeodeticLength};
