import{ix as v,L as y,bE as c,iy as M,bh as d,iz as h,iA as g,iB as I,iC as w,iD as S}from"./chunk-XGpVqsM_.js";import{u as x,c as l,i as $,f as F}from"./chunk-B90GZxcS.js";import"./chunk-DyqHK6XP.js";import"./chunk-Dix477Sg.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-CrMA_peF.js";import"./chunk-DTEy8D70.js";class O{transform(t){const r=this._transform(t),o=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&o.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&v(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&o.push(n.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(t){const r=x(t.schema,t.geometryBuffer);let o=r.length/3,n=null;const f=new Array,a=l(t.primaryAttributeData,r,o);t.primaryAttributeData!=null&&a&&f.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:a});const m=l(t.modulationAttributeData,r,o);t.modulationAttributeData!=null&&m&&f.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:m});let i=$(t.rendererInfo,a,m,o);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const s=t.filterAttributesData.filter(y).map((e=>{const D=l(e,r,o),b={attributeInfo:e.attributeInfo,values:D};return f.push(b),b}));n=new Uint32Array(o),o=F(r,i,n,t.filterInfo,s)}for(const s of t.userAttributesData){const e=l(s,r,o);f.push({attributeInfo:s.attributeInfo,values:e})}3*o<i.length&&(i=new Uint8Array(i.buffer.slice(0,3*o))),B(r,o,t.elevationOffset);const p=z(r,o,M.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:p,rgb:i,attributes:f,pointIdFilterMap:n}}}function z(u,t,r,o,n){if(!d(u,o,0,u,n,0,t))throw new Error("Can't reproject");const f=h(r.center),a=I(),m=I(),i=h(r.halfSize);g(A,r.quaternion);const p=new Float32Array(3*t);for(let s=0;s<t;s++){let e=3*s;a[0]=u[e]-f[0],a[1]=u[e+1]-f[1],a[2]=u[e+2]-f[2],w(m,a,A),i[0]=Math.max(i[0],Math.abs(m[0])),i[1]=Math.max(i[1],Math.abs(m[1])),i[2]=Math.max(i[2],Math.abs(m[2])),p[e++]=a[0],p[e++]=a[1],p[e]=a[2]}return r.halfSize=i,p}function B(u,t,r){if(r!==0)for(let o=0;o<t;o++)u[3*o+2]+=r}const A=S();function yt(){return new O}export{yt as default};
