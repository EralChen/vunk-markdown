import{ey as p,c5 as h,fL as d,V as f,Y as n,c3 as u,ar as s,as as a,au as c}from"./chunk-BLrLWCUc.js";import{l as g}from"./chunk-DSLSEsX7.js";import{p as y}from"./chunk-K-GSFTCJ.js";import{i as I}from"./chunk-CShYxIFR.js";import"./chunk-CWUYlh1e.js";import"./chunk-BDqMgIU1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */let r=class extends p(y(g(u))){constructor(){super(...arguments),this.type="wmts-3d"}initialize(){this._getCompatibleTileInfoMatrixSet(t=>this._getTileInfoSupportError(t.tileInfo,t.fullExtent));const i=h(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const t=this._getCompatibleTileInfoMatrixSet(e=>this._getTileInfoError(e.tileInfo,e.fullExtent));t!=null&&(t.id!==null&&this.layer.activeLayer.tileMatrixSetId!==t.id&&(this.layer.activeLayer.tileMatrixSetId=t.id),t.tileInfo&&(this.tileInfo=t.tileInfo),this.layer.fullExtent=t.fullExtent)});this.addResolvingPromise(i),this.when(()=>this._postInitialize())}refresh(){this.emit("data-changed")}canResume(){if(!super.canResume())return!1;const i=this.layer.activeLayer.tileMatrixSet;return i!=null&&!this._getTileInfoError(i.tileInfo,i.fullExtent)}async fetchTile(i,t){return I(this,i,t)}async doRefresh(){this.suspended||this.emit("data-changed")}_postInitialize(){this._updatingHandles.add(()=>this.layer?.activeLayer?.styleId,()=>this.refresh()),this._updatingHandles.add(()=>this.layer?.activeLayer,i=>{const t=this._getCompatibleTileInfoMatrixSet(e=>this._getTileInfoError(e.tileInfo,e.fullExtent),!0);t&&t.id!=null&&i.tileMatrixSetId!==t.id&&(this.layer.activeLayer.tileMatrixSetId=t.id),this.notifyChange("suspended"),this.canResume()&&this.refresh()})}_getCompatibleTileInfoMatrixSet(i,t=!1){const e=d(this.layer);if(e!=null){if(f.isCollection(e))return e.find(m=>{const o=i(m);return o!=null&&(t?n.getLogger(this).error("The selected tile matrix set is not compatible with the view",o):this.addResolvingPromise(Promise.reject(o))),o==null});const l=i(e);return l!=null&&(t?n.getLogger(this).error("The selected tile matrix set is not compatible with the view",l):this.addResolvingPromise(Promise.reject(l))),e}return null}_getTileInfoError(i,t){return this._getTileInfoSupportError(i,t)||this._getTileInfoCompatibilityError(i,this.view.basemapTerrain.tilingScheme)}};s([a()],r.prototype,"layer",void 0),s([a()],r.prototype,"suspended",void 0),s([a()],r.prototype,"tileInfo",void 0),r=s([c("esri.views.3d.layers.WMTSLayerView3D")],r);const nt=r;export{nt as default};
