import{_ as h,m as j,c as F,a as Y,b as H,l as i,g as V,i as x,u as U,s as $,d as q,e as z,p as P,f as K,h as Q,j as W,k as Z}from"./chunk-CV85VB2U.js";import{G as B}from"./chunk-Dd0slOaU.js";import{l as I}from"./chunk-CWmXhY-x.js";import{c as L}from"./chunk-ei8CFR7m.js";import{m as _}from"./chunk-B950-bov.js";/* empty css              *//* empty css              */import"./chunk-Biui6BxF.js";import"./chunk-C26dHzD_.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-JOSNoPqv.js";function E(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return x(e.graph())||(n.value=L(e.graph())),n}function ee(e){return _(e.nodes(),function(n){var t=e.node(n),c=e.parent(n),d={v:n};return x(t)||(d.value=t),x(c)||(d.parent=c),d})}function ne(e){return _(e.edges(),function(n){var t=e.edge(n),c={v:n.v,w:n.w};return x(n.name)||(c.name=n.name),x(t)||(c.value=t),c})}var u=new Map,b=new Map,A=new Map,te=h(()=>{b.clear(),A.clear(),u.clear()},"clear"),O=h((e,n)=>{const t=b.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ie=h((e,n)=>{const t=b.get(n)||[];return i.info("Descendants of ",n," is ",t),i.info("Edge is ",e),e.v===n||e.w===n?!1:t?t.includes(e.v)||O(e.v,n)||O(e.w,n)||t.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),J=h((e,n,t,c)=>{i.warn("Copying children of ",e,"root",c,"data",n.node(e),c);const d=n.children(e)||[];e!==c&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(l=>{if(n.children(l).length>0)J(l,n,t,c);else{const o=n.node(l);i.info("cp ",l," to ",c," with parent ",e),t.setNode(l,o),c!==n.parent(l)&&(i.warn("Setting parent",l,n.parent(l)),t.setParent(l,n.parent(l))),e!==c&&l!==e?(i.debug("Setting parent",l,e),t.setParent(l,e)):(i.info("In copy ",e,"root",c,"data",n.node(e),c),i.debug("Not Setting parent for node=",l,"cluster!==rootId",e!==c,"node!==clusterId",l!==e));const m=n.edges(l);i.debug("Copying Edges",m),m.forEach(a=>{i.info("Edge",a);const v=n.edge(a.v,a.w,a.name);i.info("Edge data",v,c);try{ie(a,c)?(i.info("Copying as ",a.v,a.w,v,a.name),t.setEdge(a.v,a.w,v,a.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",c," clusterId:",e)}catch(S){i.error(S)}})}i.debug("Removing node",l),n.removeNode(l)})},"copy"),G=h((e,n)=>{const t=n.children(e);let c=[...t];for(const d of t)A.set(d,e),c=[...c,...G(d,n)];return c},"extractDescendants"),re=h((e,n,t)=>{const c=e.edges().filter(a=>a.v===n||a.w===n),d=e.edges().filter(a=>a.v===t||a.w===t),l=c.map(a=>({v:a.v===n?t:a.v,w:a.w===n?n:a.w})),o=d.map(a=>({v:a.v,w:a.w}));return l.filter(a=>o.some(v=>a.v===v.v&&a.w===v.w))},"findCommonEdges"),D=h((e,n,t)=>{const c=n.children(e);if(i.trace("Searching children of id ",e,c),c.length<1)return e;let d;for(const l of c){const o=D(l,n,t),m=re(n,t,o);if(o)if(m.length>0)d=o;else return o}return d},"findNonClusterChild"),k=h(e=>!u.has(e)||!u.get(e).externalConnections?e:u.has(e)?u.get(e).id:e,"getAnchorId"),oe=h((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",D(t,e,t)),b.set(t,G(t,e)),u.set(t,{id:D(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const c=e.children(t),d=e.edges();c.length>0?(i.debug("Cluster identified",t,b),d.forEach(l=>{const o=O(l.v,t),m=O(l.w,t);o^m&&(i.warn("Edge: ",l," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",b.get(t)),u.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,b)});for(let t of u.keys()){const c=u.get(t).id,d=e.parent(c);d!==t&&u.has(d)&&!u.get(d).externalConnections&&(u.get(t).id=d)}e.edges().forEach(function(t){const c=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let d=t.v,l=t.w;if(i.warn("Fix XXX",u,"ids:",t.v,t.w,"Translating: ",u.get(t.v)," --- ",u.get(t.w)),u.get(t.v)||u.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),d=k(t.v),l=k(t.w),e.removeEdge(t.v,t.w,t.name),d!==t.v){const o=e.parent(d);u.get(o).externalConnections=!0,c.fromCluster=t.v}if(l!==t.w){const o=e.parent(l);u.get(o).externalConnections=!0,c.toCluster=t.w}i.warn("Fix Replacing with XXX",d,l,t.name),e.setEdge(d,l,c,t.name)}}),i.warn("Adjusted Graph",E(e)),R(e,0),i.trace(u)},"adjustClustersAndEdges"),R=h((e,n)=>{var t,c;if(i.warn("extractor - ",n,E(e),e.children("D")),n>10){i.error("Bailing out");return}let d=e.nodes(),l=!1;for(const o of d){const m=e.children(o);l=l||m.length>0}if(!l){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",d,n);for(const o of d)if(i.debug("Extracting node",o,u,u.has(o)&&!u.get(o).externalConnections,!e.parent(o),e.node(o),e.children("D")," Depth ",n),!u.has(o))i.debug("Not a cluster",o,n);else if(!u.get(o).externalConnections&&e.children(o)&&e.children(o).length>0){i.warn("Cluster without external connections, without a parent and with children",o,n);let a=e.graph().rankdir==="TB"?"LR":"TB";(c=(t=u.get(o))==null?void 0:t.clusterData)!=null&&c.dir&&(a=u.get(o).clusterData.dir,i.warn("Fixing dir",u.get(o).clusterData.dir,a));const v=new B({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",E(e)),J(o,e,v,o),e.setNode(o,{clusterNode:!0,id:o,clusterData:u.get(o).clusterData,label:u.get(o).label,graph:v}),i.warn("New graph after copy node: (",o,")",E(v)),i.debug("Old graph after copy",E(e))}else i.warn("Cluster ** ",o," **not meeting the criteria !externalConnections:",!u.get(o).externalConnections," no parent: ",!e.parent(o)," children ",e.children(o)&&e.children(o).length>0,e.children("D"),n),i.debug(u);d=e.nodes(),i.warn("New list of nodes",d);for(const o of d){const m=e.node(o);i.warn(" Now next level",o,m),m?.clusterNode&&R(m.graph,n+1)}},"extractor"),T=h((e,n)=>{if(n.length===0)return[];let t=Object.assign([],n);return n.forEach(c=>{const d=e.children(c),l=T(e,d);t=[...t,...l]}),t},"sorter"),se=h(e=>T(e,e.children()),"sortNodesByHierarchy"),M=h(async(e,n,t,c,d,l)=>{i.warn("Graph in recursive render:XAX",E(n),d);const o=n.graph().rankdir;i.trace("Dir in recursive render - dir:",o);const m=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));const a=m.insert("g").attr("class","clusters"),v=m.insert("g").attr("class","edgePaths"),S=m.insert("g").attr("class","edgeLabels"),p=m.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(f){const s=n.node(f);if(d!==void 0){const r=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,r.height,`
Parent cluster`,d.height),n.setNode(d.id,r),n.parent(f)||(i.trace("Setting parent",f,d.id),n.setParent(f,d.id,r))}if(i.info("(Insert) Node XXX"+f+": "+JSON.stringify(n.node(f))),s?.clusterNode){i.info("Cluster identified XBX",f,s.width,n.node(f));const{ranksep:r,nodesep:w}=n.graph();s.graph.setGraph({...s.graph.graph(),ranksep:r+25,nodesep:w});const N=await M(p,s.graph,t,c,n.node(f),l),C=N.elem;U(s,C),s.diff=N.diff||0,i.info("New compound node after recursive render XAX",f,"width",s.width,"height",s.height),$(C,s)}else n.children(f).length>0?(i.trace("Cluster - the non recursive path XBX",f,s.id,s,s.width,"Graph:",n),i.trace(D(s.id,n)),u.set(s.id,{id:D(s.id,n),node:s})):(i.trace("Node - the non recursive path XAX",f,p,n.node(f),o),await q(p,n.node(f),{config:l,dir:o}))})),await h(async()=>{const f=n.edges().map(async function(s){const r=n.edge(s.v,s.w,s.name);i.info("Edge "+s.v+" -> "+s.w+": "+JSON.stringify(s)),i.info("Edge "+s.v+" -> "+s.w+": ",s," ",JSON.stringify(n.edge(s))),i.info("Fix",u,"ids:",s.v,s.w,"Translating: ",u.get(s.v),u.get(s.w)),await Z(S,r)});await Promise.all(f)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(E(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),I(n),i.info("Graph after layout:",JSON.stringify(E(n)));let y=0,{subGraphTitleTotalMargin:X}=z(l);return await Promise.all(se(n).map(async function(f){var s;const r=n.node(f);if(i.info("Position XBX => "+f+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height),r?.clusterNode)r.y+=X,i.info("A tainted cluster node XBX1",f,r.id,r.width,r.height,r.x,r.y,n.parent(f)),u.get(r.id).node=r,P(r);else if(n.children(f).length>0){i.info("A pure cluster node XBX1",f,r.id,r.x,r.y,r.width,r.height,n.parent(f)),r.height+=X,n.node(r.parentId);const w=r?.padding/2||0,N=((s=r?.labelBBox)==null?void 0:s.height)||0,C=N-w||0;i.debug("OffsetY",C,"labelHeight",N,"halfPadding",w),await K(a,r),u.get(r.id).node=r}else{const w=n.node(r.parentId);r.y+=X/2,i.info("A regular node XBX1 - using the padding",r.id,"parent",r.parentId,r.width,r.height,r.x,r.y,"offsetY",r.offsetY,"parent",w,w?.offsetY,r),P(r)}})),n.edges().forEach(function(f){const s=n.edge(f);i.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(s),s),s.points.forEach(C=>C.y+=X/2);const r=n.node(f.v);var w=n.node(f.w);const N=Q(v,s,u,t,r,w,c);W(s,N)}),n.nodes().forEach(function(f){const s=n.node(f);i.info(f,s.type,s.diff),s.isGroup&&(y=s.diff)}),i.warn("Returning from recursive render XAX",m,y),{elem:m,diff:y}},"recursiveRender"),yn=h(async(e,n)=>{var t,c,d,l,o,m;const a=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((t=e.config)==null?void 0:t.nodeSpacing)||((d=(c=e.config)==null?void 0:c.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((m=(o=e.config)==null?void 0:o.flowchart)==null?void 0:m.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),v=n.select("g");j(v,e.markers,e.type,e.diagramId),F(),Y(),H(),te(),e.nodes.forEach(p=>{a.setNode(p.id,{...p}),p.parentId&&a.setParent(p.id,p.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(p=>{if(p.start===p.end){const g=p.start,y=g+"---"+g+"---1",X=g+"---"+g+"---2",f=a.node(g);a.setNode(y,{domId:y,id:y,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),a.setParent(y,f.parentId),a.setNode(X,{domId:X,id:X,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),a.setParent(X,f.parentId);const s=structuredClone(p),r=structuredClone(p),w=structuredClone(p);s.label="",s.arrowTypeEnd="none",s.id=g+"-cyclic-special-1",r.arrowTypeStart="none",r.arrowTypeEnd="none",r.id=g+"-cyclic-special-mid",w.label="",f.isGroup&&(s.fromCluster=g,w.toCluster=g),w.id=g+"-cyclic-special-2",w.arrowTypeStart="none",a.setEdge(g,y,s,g+"-cyclic-special-0"),a.setEdge(y,X,r,g+"-cyclic-special-1"),a.setEdge(X,g,w,g+"-cyc<lic-special-2")}else a.setEdge(p.start,p.end,{...p},p.id)}),i.warn("Graph at first:",JSON.stringify(E(a))),oe(a),i.warn("Graph after XAX:",JSON.stringify(E(a)));const S=V();await M(v,a,e.type,e.diagramId,void 0,S)},"render");export{yn as render};
