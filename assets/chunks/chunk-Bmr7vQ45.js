import{as as b,c2 as P,n as w,f5 as E,dT as N,mv as H,mw as T,eZ as z,c4 as j,fE as k,i4 as q,i7 as B,aj as d,ak as l,am as C}from"./chunk-XGpVqsM_.js";const I=Math.PI/180;function A(e){return e*I}function O(e,i){const s=A(i.rotation),t=Math.abs(Math.cos(s)),r=Math.abs(Math.sin(s)),[a,n]=i.size;return e[0]=Math.round(n*r+a*t),e[1]=Math.round(n*t+a*r),e}function U(e,i,s,t){const[r,a]=i,[n,o]=t,c=.5*s;return e[0]=r-c*n,e[1]=a-c*o,e[2]=r+c*n,e[3]=a+c*o,e}const u=j(),m=[0,0],v=new B(0,0,0,0),y={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let p=class extends b{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=y.hidpi,this.imageMaxWidth=y.imageMaxWidth,this.imageMaxHeight=y.imageMaxHeight,this.imageRotationSupported=y.imageRotationSupported,this.imageNormalizationSupported=y.imageNormalizationSupported,this.update=P((async(i,s)=>{if(w(s),!i.stationary||this.destroyed)return;const t=i.state,r=E(t.spatialReference),a=this.hidpi?i.pixelRatio:1,n=t.worldScreenWidth>0,o=n&&this.imageNormalizationSupported&&t.worldScreenWidth<t.size[0],c=Math.round((this.imageMaxWidth??0)/a),f=Math.round((this.imageMaxHeight??0)/a);o?(m[0]=t.worldScreenWidth,m[1]=t.size[1]):this.imageRotationSupported?(m[0]=t.size[0],m[1]=t.size[1]):O(m,t);const M=Math.floor(m[0])>c||Math.floor(m[1])>f,S=r&&(t.extent.xmin<r.valid[0]||t.extent.xmax>r.valid[1]),_=!this.imageNormalizationSupported&&S,x=!M&&!_,W=this.imageRotationSupported?t.rotation:0,$=this.container.children.slice();if(x){const h=o?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,m,h,t.resolution,W,a,s)}else{let h=Math.min(c,f);n&&(h=Math.min(t.worldScreenWidth,h),h=Math.round(t.worldScreenWidth/Math.ceil(t.worldScreenWidth/h))),this._imagePromise=this._tiledExport(t,h,a,s)}try{const h=await this._imagePromise??[];w(s);const R=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=h;for(const g of $)h.includes(g)||R.push(g.fadeOut().then((()=>{g.remove(),g.destroy()})));for(const g of h)R.push(g.fadeIn());await Promise.all(R)}catch(h){this._imagePromise=null,N(h)}}),5e3),this.updateExports=P((async i=>{const s=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;s.push(i(t).then((()=>{t.invalidateTexture(),t.requestRender()})))}this._imagePromise=H(s).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((e=>e.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(e,i,s,t,r,a){const n=await this.fetchSource(e,Math.floor(i*r),Math.floor(s*r),{rotation:t,pixelRatio:r,signal:a});w(a);const o=new T(null,!0);return o.x=e.xmin,o.y=e.ymax,o.resolution=e.width/i,o.rotation=t,o.pixelRatio=r,o.opacity=0,this.container.addChild(o),await o.setSourceAsync(n,a),w(a),o}async _singleExport(e,i,s,t,r,a,n){U(u,s,t,i);const o=z(u,e.spatialReference);return[await this._export(o,i[0],i[1],r,a,n)]}_tiledExport(e,i,s,t){const r=k.create({size:i,spatialReference:e.spatialReference,scales:[e.scale]}),a=new q(r),n=a.getTileCoverage(e);if(!n)return null;const o=[];return n.forEach(((c,f,M,S)=>{v.set(c,f,M,0),a.getTileBounds(u,v);const _=z(u,e.spatialReference);o.push(this._export(_,i,i,0,s,t).then((x=>(S!==0&&(v.set(c,f,M,S),a.getTileBounds(u,v),x.x=u[0],x.y=u[3]),x))))})),Promise.all(o)}};d([l()],p.prototype,"_imagePromise",void 0),d([l()],p.prototype,"bitmaps",void 0),d([l()],p.prototype,"container",void 0),d([l()],p.prototype,"fetchSource",void 0),d([l()],p.prototype,"hidpi",void 0),d([l()],p.prototype,"imageMaxWidth",void 0),d([l()],p.prototype,"imageMaxHeight",void 0),d([l()],p.prototype,"imageRotationSupported",void 0),d([l()],p.prototype,"imageNormalizationSupported",void 0),d([l()],p.prototype,"requestUpdate",void 0),d([l()],p.prototype,"updating",null),p=d([C("esri.views.2d.layers.support.ExportStrategy")],p);export{p as M};
