import{I as l,Q as f,fR as c,P as y,dz as S,fZ as u,fY as R,a4 as g,kQ as d,fV as x,kR as J}from"./chunk-BrJ3DEnk.js";import"./chunk-B5uEfUiB.js";import"./chunk-BY4ynHbL.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-SqlbPPT2.js";function N(e){const i=e.geometry,r=e.toJSON(),t=r;let m,o,n;if(i!=null&&(o=i.spatialReference,n=u(o),t.geometryType=R(i),t.geometry=JSON.stringify(i),t.inSR=n),r.outSR?(t.outSR=u(r.outSR),m=e.outSpatialReference):i&&(t.outSR=t.inSR,m=o),t.bin&&=JSON.stringify(t.bin),t.quantizationParameters&&=JSON.stringify(t.quantizationParameters),t.outStatistics&&=JSON.stringify(t.outStatistics),t.outTimeReference&&=JSON.stringify(t.outTimeReference),r.timeExtent){const p=r.timeExtent,{start:a,end:s}=p;a==null&&s==null||(t.time=a===s?a:`${a??"null"},${s??"null"}`),delete r.timeExtent}return e.defaultSpatialReference&&g(o,m)&&(t.defaultSR=t.inSR,delete t.inSR,delete t.outSR),t}async function O(e,i,r){return i.timeExtent!=null&&i.timeExtent.isEmpty?{data:{features:[]}}:await q(e,i,r)}async function q(e,i,r={}){const t=typeof e=="string"?l(e):e,m=i.geometry?[i.geometry]:[],o=await f(m,null,{signal:r.signal}),n=o?.[0];n!=null&&((i=i.clone()).geometry=n);const p=c({...t.query,f:"json",...N(i)});return y(S(t.path,"queryBins"),{...r,query:{...p,...r.query}})}async function ut(e,i,r){const{data:t}=await O(x(e),d.from(i),r);return J.fromJSON(t)}export{ut as executeAttributeBinsQuery};
