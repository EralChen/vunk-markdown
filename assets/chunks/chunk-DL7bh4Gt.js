import{he as M,hf as d,hg as v,y as u,hh as C,fm as I,hi as h,hj as x,hk as k,hl as O,hm as S,au as N}from"./chunk-XGpVqsM_.js";import P from"./chunk-B8YJNhTg.js";import"./chunk-DyqHK6XP.js";import"./chunk-Dix477Sg.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-CrMA_peF.js";const T=f=>{if(!f)return[0,0,0,0];const{r:e,g:r,b:t,a:i}=f;return[e,r,t,255*i]};class s{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let i=!1;for(const o of t)if(o.primitiveName===e.primitiveName){i=!0;break}if(!i)for(const o of r)o.primitiveName===e.primitiveName&&t.push(o)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)s.findApplicableOverrides(i,r,t);if(e.symbolLayers)for(const i of e.symbolLayers)s.findApplicableOverrides(i,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const i of e.effects)s.findApplicableOverrides(i,r,t);if(e.markerPlacement&&s.findApplicableOverrides(e.markerPlacement,r,t),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const i of e.markerGraphics)s.findApplicableOverrides(i,r,t),s.findApplicableOverrides(i.symbol,r,t)}else e.type==="CIMCharacterMarker"?s.findApplicableOverrides(e.symbol,r,t):e.type==="CIMHatchFill"?s.findApplicableOverrides(e.lineSymbol,r,t):e.type==="CIMPictureMarker"&&s.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&M(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=d(e),i=e.primitiveName,o=[];for(const a of r)a.primitiveName===i&&o.push(d(a));return{type:"cim-effect-param",effect:t,overrides:v(o)}}static async resolveSymbolOverrides(e,r,t,i,o,a,p){if(!e?.symbol)return null;let{symbol:c,primitiveOverrides:l}=e;const m=!!l;if(!m&&!i)return c;c=u(c),l=u(l);let y=!0;if(r||(r={attributes:{}},y=!1),m){if(y||(l=l.filter((n=>!n.valueExpressionInfo?.expression.includes("$feature")))),p||(l=l.filter((n=>!n.valueExpressionInfo?.expression.includes("$view")))),l.length>0){const n=C(r.attributes),b={spatialReference:t,fields:n,geometryType:o};await s.createRenderExpressions(l,b),s.evaluateOverrides(l,r,o??"esriGeometryPoint",a,p,new I(n))}s.applyOverrides(c,l)}return i&&s.applyDictionaryTextOverrides(c,r,i,null),c}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const t=[];for(const i of e){const o=i.valueExpressionInfo;if(!o||s._expressionToRenderExpression.has(o.expression))continue;const a=h(o.expression,r.spatialReference);t.push(a),a.then((p=>s._expressionToRenderExpression.set(o.expression,p)))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,r,t,i,o,a){const p={$view:{scale:o?.scale}};for(const c of e){c.value&&typeof c.value=="object"&&x(c.value)&&(c.propertyName==="Color"||c.propertyName==="StrokeColor")&&(c.value=T(c.value));const l=c.valueExpressionInfo;if(!l)continue;const m=s._expressionToRenderExpression.get(l.expression);m&&(c.value=P(m,r,p,t,a,i))}}static applyDictionaryTextOverrides(e,r,t,i,o="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const a=e.symbolLayers;if(!a)return;for(const p of a)p&&p.type==="CIMVectorMarker"&&s.applyDictionaryTextOverrides(p,r,t,i,e.type==="CIMTextSymbol"?e.textCase:o)}break;case"CIMVectorMarker":{const a=e.markerGraphics;if(!a)return;for(const p of a)p&&s.applyDictionaryTextOverrides(p,r,t,i)}break;case"CIMMarkerGraphic":{const a=e.textString;if(a&&a.includes("[")){const p=k(a,t);e.textString=O(r,p,i,o)}}}}static applyOverrides(e,r,t,i){if(e.primitiveName){for(const o of r)if(o.primitiveName===e.primitiveName){const a=S(o.propertyName);if(i&&i.push({cim:e,nocapPropertyName:a,value:e[a]}),t){let p=!1;for(const c of t)c.primitiveName===e.primitiveName&&(p=!0);p||t.push(o)}o.value!=null&&(e[a]=o.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const o of e.effects)s.applyOverrides(o,r,t,i);if(e.symbolLayers)for(const o of e.symbolLayers)s.applyOverrides(o,r,t,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const o of e.effects)s.applyOverrides(o,r,t,i);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const o of e.markerGraphics)s.applyOverrides(o,r,t,i),s.applyOverrides(o.symbol,r,t,i)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)t.value!==void 0&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map((t=>Number(t)));if(e==="Color"){const t=new N(r).toRgba();return t[3]*=255,t}return r}}export{s as OverrideHelper};
