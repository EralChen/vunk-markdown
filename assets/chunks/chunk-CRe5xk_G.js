import{Ix as b,HO as x,HU as E,HP as D,HS as y,HQ as O,Ij as w,HR as A,b8 as o,IG as g,HN as m,HT as S,HM as C,IH as H,u2 as N,HY as R,HZ as M,H_ as V,H$ as j,Ik as L,Il as F,Im as z,In as B,I1 as U,I2 as W,I3 as k,Ip as q,I4 as G,Iy as Q,II as J,I6 as K,I7 as Y,ky as I,rF as Z,I8 as X,af as u,I9 as c,qD as h,IJ as _,IK as f,It as ee,Ib as te,Ic as se,IL as re,Iu as ie,xn as ae,IM as oe,IN as ne,rH as le}from"./chunk-CuaFhuP3.js";import{c as ue}from"./chunk-6vejsciN.js";import{r as ce}from"./chunk-B6pR6iCC.js";import{_ as pe}from"./chunk-iOPJXyP1.js";import"./chunk-Dpk1TJd9.js";class P extends b{}function T(s){const e=new x,{vertex:t,fragment:i,varyings:p}=e,{output:n,perspectiveInterpolation:l}=s;return E(t,s),e.include(D,s),e.include(y,s),e.fragment.include(O,s),e.include(w,s),e.include(A,s),e.attributes.add(o.POSITION,"vec3"),e.attributes.add(o.UV0,"vec2"),l&&e.attributes.add(o.PERSPECTIVEDIVIDE,"float"),t.main.add(m`
    vpos = position;
    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    vTexCoord = uv0;
    gl_Position = transformPosition(proj, view, vpos);
    ${g(l,"gl_Position *= perspectiveDivide;")}`),p.add("vpos","vec3",{invariant:!0}),p.add("vTexCoord","vec2"),i.include(S),i.uniforms.add(new C("opacity",(r=>r.opacity)),new H("tex",(r=>r.glTexture))).main.add(m`
    discardBySlice(vpos);
    discardByTerrainDepth();
    ${g(n===N.ObjectAndLayerIdColor,"fragColor = vec4(0, 0, 0, 1); return;")}
    vec4 finalColor = texture(tex, vTexCoord) * opacity;
    outputColorHighlightOID(finalColor, vpos, finalColor.rgb);`),e}const de=Object.freeze(Object.defineProperty({__proto__:null,ImageMaterialPassParameters:P,build:T},Symbol.toStringTag,{value:"Module"}));class he extends R{constructor(e,t){super(e,t,new M(de,(()=>pe(()=>Promise.resolve().then(()=>ge),void 0))),$)}_getPipelineState(e,t){const{oitPass:i,output:p,hasOccludees:n,cullFace:l}=e,r=i===V.NONE;return j({blending:K(p)?r?Q:J(i):null,culling:G(l),depthTest:{func:q(i)},depthWrite:k(e),drawBuffers:W(i,p),colorWrite:U,stencilWrite:n?B:null,stencilTest:n?t?F:z:null,polygonOffset:L(e)})}initializePipeline(e){return this._occludeePipeline=this._getPipelineState(e,!0),this._getPipelineState(e,!1)}getPipeline(e){return e?this._occludeePipeline:super.getPipeline()}}const $=new Map([[o.POSITION,0],[o.UV0,2],[o.PERSPECTIVEDIVIDE,3]]);class a extends Y{constructor(e){super(),this.draped=e,this.cullFace=I.None,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.perspectiveInterpolation=!0,this.textureCoordinateType=Z.None,this.emissionSource=X.None,this.discardInvisibleFragments=!0,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1,this.snowCover=!1}}u([c({count:I.COUNT})],a.prototype,"cullFace",void 0),u([c()],a.prototype,"enableOffset",void 0),u([c()],a.prototype,"writeDepth",void 0),u([c()],a.prototype,"hasOccludees",void 0),u([c()],a.prototype,"terrainDepthTest",void 0),u([c()],a.prototype,"cullAboveTerrain",void 0),u([c()],a.prototype,"perspectiveInterpolation",void 0);class be extends ce{constructor(e){super(e,ve),this.vertexAttributeLocations=$,this.supportsEdges=!0,this.produces=new Map([[h.OPAQUE_MATERIAL,t=>_(t)],[h.TRANSPARENT_MATERIAL,t=>f(t)&&this.parameters.writeDepth],[h.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,t=>f(t)&&!this.parameters.writeDepth],[h.DRAPED_MATERIAL,t=>f(t)||_(t)]]),this._configuration=new a(e.draped)}dispose(){this.setParameters({texture:void 0})}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=t.hasOccludees,this._configuration.oitPass=t.oitPass,this._configuration.enableOffset=t.camera.relativeElevation<ee,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}get visible(){return!0}createGLMaterial(e){return new fe(e)}createBufferWriter(){let e=ue;return this.parameters.perspectiveInterpolation&&(e=e.clone().f32(o.PERSPECTIVEDIVIDE)),new Ie(e)}}class fe extends se{constructor(e){super({...e,...e.material.parameters}),this.parameters=e;const t=this._material.parameters.texture;re(t)&&e.textures.updater.add(t)}dispose(){this.parameters.textures.updater.remove(this._material.parameters.texture)}beginSlot(e){return this.getTechnique(he,e)}}class Ie extends ie{write(e,t,i,p,n,l){for(const r of this.vertexBufferLayout.fields.keys()){const d=i.get(r);if(d)if(r===o.PERSPECTIVEDIVIDE){ae(d.size===1);const v=n.getField(r,oe);v&&ne(d,v,l)}else le(r,d,e,t,n,l)}return null}}class ve extends te{constructor(e,t){super(),this.texture=e,this.draped=t,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=I.None,this.opacity=1,this.perspectiveInterpolation=!1}get glTexture(){return this.texture.glTexture}}const ge=Object.freeze(Object.defineProperty({__proto__:null,ImageMaterialPassParameters:P,build:T},Symbol.toStringTag,{value:"Module"}));export{be as _};
