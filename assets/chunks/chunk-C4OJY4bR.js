import{p as J}from"./chunk-C0UEDNSC.js";import{I as Q}from"./chunk-CogAuHCh.js";import{_ as h,an as Z,am as rr,a4 as er,a5 as tr,a6 as ar,a7 as nr,l as v,g as sr,a8 as or,al as cr,ay as ir,as as lr,af as B,az as dr,aA as hr,aB as $r,aC as fr}from"./chunk-D5VqagVh.js";import{p as pr}from"./chunk-KooHBBDB.js";/* empty css              *//* empty css              */import"./chunk-CjSkIgyx.js";import"./chunk-DB56luzt.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-CFFlADTG.js";import"./chunk-hVsT1Ltw.js";import"./chunk-q6lTXmXD.js";var m={NORMAL:0,REVERSE:1,HIGHLIGHT:2,MERGE:3,CHERRY_PICK:4},gr=$r.gitGraph,A=h(()=>dr({...gr,...hr().gitGraph}),"getConfig"),i=new Q(()=>{const e=A(),r=e.mainBranchName,t=e.mainBranchOrder;return{mainBranchName:r,commits:new Map,head:null,branchConfig:new Map([[r,{name:r,order:t}]]),branches:new Map([[r,null]]),currBranch:r,direction:"LR",seq:0,options:{}}});function F(){return fr({length:7})}h(F,"getID");function j(e,r){const t=Object.create(null);return e.reduce((o,s)=>{const c=r(s);return t[c]||(t[c]=!0,o.push(s)),o},[])}h(j,"uniqBy");var ur=h(function(e){i.records.direction=e},"setDirection"),yr=h(function(e){v.debug("options str",e),e=e?.trim(),e=e||"{}";try{i.records.options=JSON.parse(e)}catch(r){v.error("error while parsing gitGraph options",r.message)}},"setOptions"),xr=h(function(){return i.records.options},"getOptions"),mr=h(function(e){let r=e.msg,t=e.id;const o=e.type;let s=e.tags;v.info("commit",r,t,o,s),v.debug("Entering commit:",r,t,o,s);const c=A();t=B.sanitizeText(t,c),r=B.sanitizeText(r,c),s=s?.map(l=>B.sanitizeText(l,c));const d={id:t||i.records.seq+"-"+F(),message:r,seq:i.records.seq++,type:o??m.NORMAL,tags:s??[],parents:i.records.head==null?[]:[i.records.head.id],branch:i.records.currBranch};i.records.head=d,v.info("main branch",c.mainBranchName),i.records.commits.set(d.id,d),i.records.branches.set(i.records.currBranch,d.id),v.debug("in pushCommit "+d.id)},"commit"),br=h(function(e){let r=e.name;const t=e.order;if(r=B.sanitizeText(r,A()),i.records.branches.has(r))throw new Error(`Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${r}")`);i.records.branches.set(r,i.records.head!=null?i.records.head.id:null),i.records.branchConfig.set(r,{name:r,order:t}),Y(r),v.debug("in createBranch")},"branch"),vr=h(e=>{let r=e.branch,t=e.id;const o=e.type,s=e.tags,c=A();r=B.sanitizeText(r,c),t&&(t=B.sanitizeText(t,c));const d=i.records.branches.get(i.records.currBranch),l=i.records.branches.get(r),f=d?i.records.commits.get(d):void 0,a=l?i.records.commits.get(l):void 0;if(f&&a&&f.branch===r)throw new Error(`Cannot merge branch '${r}' into itself.`);if(i.records.currBranch===r){const $=new Error('Incorrect usage of "merge". Cannot merge a branch to itself');throw $.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["branch abc"]},$}if(f===void 0||!f){const $=new Error(`Incorrect usage of "merge". Current branch (${i.records.currBranch})has no commits`);throw $.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["commit"]},$}if(!i.records.branches.has(r)){const $=new Error('Incorrect usage of "merge". Branch to be merged ('+r+") does not exist");throw $.hash={text:`merge ${r}`,token:`merge ${r}`,expected:[`branch ${r}`]},$}if(a===void 0||!a){const $=new Error('Incorrect usage of "merge". Branch to be merged ('+r+") has no commits");throw $.hash={text:`merge ${r}`,token:`merge ${r}`,expected:['"commit"']},$}if(f===a){const $=new Error('Incorrect usage of "merge". Both branches have same head');throw $.hash={text:`merge ${r}`,token:`merge ${r}`,expected:["branch abc"]},$}if(t&&i.records.commits.has(t)){const $=new Error('Incorrect usage of "merge". Commit with id:'+t+" already exists, use different custom Id");throw $.hash={text:`merge ${r} ${t} ${o} ${s?.join(" ")}`,token:`merge ${r} ${t} ${o} ${s?.join(" ")}`,expected:[`merge ${r} ${t}_UNIQUE ${o} ${s?.join(" ")}`]},$}const n=l||"",x={id:t||`${i.records.seq}-${F()}`,message:`merged branch ${r} into ${i.records.currBranch}`,seq:i.records.seq++,parents:i.records.head==null?[]:[i.records.head.id,n],branch:i.records.currBranch,type:m.MERGE,customType:o,customId:!!t,tags:s??[]};i.records.head=x,i.records.commits.set(x.id,x),i.records.branches.set(i.records.currBranch,x.id),v.debug(i.records.branches),v.debug("in mergeBranch")},"merge"),wr=h(function(e){let r=e.id,t=e.targetId,o=e.tags,s=e.parent;v.debug("Entering cherryPick:",r,t,o);const c=A();if(r=B.sanitizeText(r,c),t=B.sanitizeText(t,c),o=o?.map(f=>B.sanitizeText(f,c)),s=B.sanitizeText(s,c),!r||!i.records.commits.has(r)){const f=new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');throw f.hash={text:`cherryPick ${r} ${t}`,token:`cherryPick ${r} ${t}`,expected:["cherry-pick abc"]},f}const d=i.records.commits.get(r);if(d===void 0||!d)throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');if(s&&!(Array.isArray(d.parents)&&d.parents.includes(s)))throw new Error("Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.");const l=d.branch;if(d.type===m.MERGE&&!s)throw new Error("Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.");if(!t||!i.records.commits.has(t)){if(l===i.records.currBranch){const x=new Error('Incorrect usage of "cherryPick". Source commit is already on current branch');throw x.hash={text:`cherryPick ${r} ${t}`,token:`cherryPick ${r} ${t}`,expected:["cherry-pick abc"]},x}const f=i.records.branches.get(i.records.currBranch);if(f===void 0||!f){const x=new Error(`Incorrect usage of "cherry-pick". Current branch (${i.records.currBranch})has no commits`);throw x.hash={text:`cherryPick ${r} ${t}`,token:`cherryPick ${r} ${t}`,expected:["cherry-pick abc"]},x}const a=i.records.commits.get(f);if(a===void 0||!a){const x=new Error(`Incorrect usage of "cherry-pick". Current branch (${i.records.currBranch})has no commits`);throw x.hash={text:`cherryPick ${r} ${t}`,token:`cherryPick ${r} ${t}`,expected:["cherry-pick abc"]},x}const n={id:i.records.seq+"-"+F(),message:`cherry-picked ${d?.message} into ${i.records.currBranch}`,seq:i.records.seq++,parents:i.records.head==null?[]:[i.records.head.id,d.id],branch:i.records.currBranch,type:m.CHERRY_PICK,tags:o?o.filter(Boolean):[`cherry-pick:${d.id}${d.type===m.MERGE?`|parent:${s}`:""}`]};i.records.head=n,i.records.commits.set(n.id,n),i.records.branches.set(i.records.currBranch,n.id),v.debug(i.records.branches),v.debug("in cherryPick")}},"cherryPick"),Y=h(function(e){if(e=B.sanitizeText(e,A()),i.records.branches.has(e)){i.records.currBranch=e;const r=i.records.branches.get(i.records.currBranch);r===void 0||!r?i.records.head=null:i.records.head=i.records.commits.get(r)??null}else{const r=new Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`);throw r.hash={text:`checkout ${e}`,token:`checkout ${e}`,expected:[`branch ${e}`]},r}},"checkout");function D(e,r,t){const o=e.indexOf(r);o===-1?e.push(t):e.splice(o,1,t)}h(D,"upsert");function N(e){const r=e.reduce((s,c)=>s.seq>c.seq?s:c,e[0]);let t="";e.forEach(function(s){s===r?t+="	*":t+="	|"});const o=[t,r.id,r.seq];for(const s in i.records.branches)i.records.branches.get(s)===r.id&&o.push(s);if(v.debug(o.join(" ")),r.parents&&r.parents.length==2&&r.parents[0]&&r.parents[1]){const s=i.records.commits.get(r.parents[0]);D(e,r,s),r.parents[1]&&e.push(i.records.commits.get(r.parents[1]))}else{if(r.parents.length==0)return;if(r.parents[0]){const s=i.records.commits.get(r.parents[0]);D(e,r,s)}}e=j(e,s=>s.id),N(e)}h(N,"prettyPrintCommitHistory");var Cr=h(function(){v.debug(i.records.commits);const e=K()[0];N([e])},"prettyPrint"),Er=h(function(){i.reset(),lr()},"clear"),Tr=h(function(){return[...i.records.branchConfig.values()].map((r,t)=>r.order!==null&&r.order!==void 0?r:{...r,order:parseFloat(`0.${t}`)}).sort((r,t)=>(r.order??0)-(t.order??0)).map(({name:r})=>({name:r}))},"getBranchesAsObjArray"),Br=h(function(){return i.records.branches},"getBranches"),Lr=h(function(){return i.records.commits},"getCommits"),K=h(function(){const e=[...i.records.commits.values()];return e.forEach(function(r){v.debug(r.id)}),e.sort((r,t)=>r.seq-t.seq),e},"getCommitsArray"),kr=h(function(){return i.records.currBranch},"getCurrentBranch"),Mr=h(function(){return i.records.direction},"getDirection"),Ir=h(function(){return i.records.head},"getHead"),U={commitType:m,getConfig:A,setDirection:ur,setOptions:yr,getOptions:xr,commit:mr,branch:br,merge:vr,cherryPick:wr,checkout:Y,prettyPrint:Cr,clear:Er,getBranchesAsObjArray:Tr,getBranches:Br,getCommits:Lr,getCommitsArray:K,getCurrentBranch:kr,getDirection:Mr,getHead:Ir,setAccTitle:nr,getAccTitle:ar,getAccDescription:tr,setAccDescription:er,setDiagramTitle:rr,getDiagramTitle:Z},Rr=h((e,r)=>{J(e,r),e.dir&&r.setDirection(e.dir);for(const t of e.statements)Gr(t,r)},"populate"),Gr=h((e,r)=>{const o={Commit:h(s=>r.commit(_r(s)),"Commit"),Branch:h(s=>r.branch(Or(s)),"Branch"),Merge:h(s=>r.merge(Ar(s)),"Merge"),Checkout:h(s=>r.checkout(qr(s)),"Checkout"),CherryPicking:h(s=>r.cherryPick(Hr(s)),"CherryPicking")}[e.$type];o?o(e):v.error(`Unknown statement type: ${e.$type}`)},"parseStatement"),_r=h(e=>({id:e.id,msg:e.message??"",type:e.type!==void 0?m[e.type]:m.NORMAL,tags:e.tags??void 0}),"parseCommit"),Or=h(e=>({name:e.name,order:e.order??0}),"parseBranch"),Ar=h(e=>({branch:e.branch,id:e.id??"",type:e.type!==void 0?m[e.type]:void 0,tags:e.tags??void 0}),"parseMerge"),qr=h(e=>e.branch,"parseCheckout"),Hr=h(e=>{var r;return{id:e.id,targetId:"",tags:((r=e.tags)==null?void 0:r.length)===0?void 0:e.tags,parent:e.parent}},"parseCherryPicking"),Pr={parse:h(async e=>{const r=await pr("gitGraph",e);v.debug(r),Rr(r,U)},"parse")},S=sr(),C=S?.gitGraph,G=10,_=40,L=4,M=2,O=8,E=new Map,T=new Map,P=30,q=new Map,z=[],R=0,y="LR",zr=h(()=>{E.clear(),T.clear(),q.clear(),R=0,z=[],y="LR"},"clear"),V=h(e=>{const r=document.createElementNS("http://www.w3.org/2000/svg","text");return(typeof e=="string"?e.split(/\\n|\n|<br\s*\/?>/gi):e).forEach(o=>{const s=document.createElementNS("http://www.w3.org/2000/svg","tspan");s.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),s.setAttribute("dy","1em"),s.setAttribute("x","0"),s.setAttribute("class","row"),s.textContent=o.trim(),r.appendChild(s)}),r},"drawText"),X=h(e=>{let r,t,o;return y==="BT"?(t=h((s,c)=>s<=c,"comparisonFunc"),o=1/0):(t=h((s,c)=>s>=c,"comparisonFunc"),o=0),e.forEach(s=>{var c,d;const l=y==="TB"||y=="BT"?(c=T.get(s))==null?void 0:c.y:(d=T.get(s))==null?void 0:d.x;l!==void 0&&t(l,o)&&(r=s,o=l)}),r},"findClosestParent"),Fr=h(e=>{let r="",t=1/0;return e.forEach(o=>{const s=T.get(o).y;s<=t&&(r=o,t=s)}),r||void 0},"findClosestParentBT"),Dr=h((e,r,t)=>{let o=t,s=t;const c=[];e.forEach(d=>{const l=r.get(d);if(!l)throw new Error(`Commit not found for key ${d}`);l.parents.length?(o=Sr(l),s=Math.max(o,s)):c.push(l),Wr(l,o)}),o=s,c.forEach(d=>{jr(d,o,t)}),e.forEach(d=>{const l=r.get(d);if(l?.parents.length){const f=Fr(l.parents);o=T.get(f).y-_,o<=s&&(s=o);const a=E.get(l.branch).pos,n=o-G;T.set(l.id,{x:a,y:n})}})},"setParallelBTPos"),Nr=h(e=>{var r;const t=X(e.parents.filter(s=>s!==null));if(!t)throw new Error(`Closest parent not found for commit ${e.id}`);const o=(r=T.get(t))==null?void 0:r.y;if(o===void 0)throw new Error(`Closest parent position not found for commit ${e.id}`);return o},"findClosestParentPos"),Sr=h(e=>Nr(e)+_,"calculateCommitPosition"),Wr=h((e,r)=>{const t=E.get(e.branch);if(!t)throw new Error(`Branch not found for commit ${e.id}`);const o=t.pos,s=r+G;return T.set(e.id,{x:o,y:s}),{x:o,y:s}},"setCommitPosition"),jr=h((e,r,t)=>{const o=E.get(e.branch);if(!o)throw new Error(`Branch not found for commit ${e.id}`);const s=r+t,c=o.pos;T.set(e.id,{x:c,y:s})},"setRootPosition"),Yr=h((e,r,t,o,s,c)=>{if(c===m.HIGHLIGHT)e.append("rect").attr("x",t.x-10).attr("y",t.y-10).attr("width",20).attr("height",20).attr("class",`commit ${r.id} commit-highlight${s%O} ${o}-outer`),e.append("rect").attr("x",t.x-6).attr("y",t.y-6).attr("width",12).attr("height",12).attr("class",`commit ${r.id} commit${s%O} ${o}-inner`);else if(c===m.CHERRY_PICK)e.append("circle").attr("cx",t.x).attr("cy",t.y).attr("r",10).attr("class",`commit ${r.id} ${o}`),e.append("circle").attr("cx",t.x-3).attr("cy",t.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${r.id} ${o}`),e.append("circle").attr("cx",t.x+3).attr("cy",t.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${r.id} ${o}`),e.append("line").attr("x1",t.x+3).attr("y1",t.y+1).attr("x2",t.x).attr("y2",t.y-5).attr("stroke","#fff").attr("class",`commit ${r.id} ${o}`),e.append("line").attr("x1",t.x-3).attr("y1",t.y+1).attr("x2",t.x).attr("y2",t.y-5).attr("stroke","#fff").attr("class",`commit ${r.id} ${o}`);else{const d=e.append("circle");if(d.attr("cx",t.x),d.attr("cy",t.y),d.attr("r",r.type===m.MERGE?9:10),d.attr("class",`commit ${r.id} commit${s%O}`),c===m.MERGE){const l=e.append("circle");l.attr("cx",t.x),l.attr("cy",t.y),l.attr("r",6),l.attr("class",`commit ${o} ${r.id} commit${s%O}`)}c===m.REVERSE&&e.append("path").attr("d",`M ${t.x-5},${t.y-5}L${t.x+5},${t.y+5}M${t.x-5},${t.y+5}L${t.x+5},${t.y-5}`).attr("class",`commit ${o} ${r.id} commit${s%O}`)}},"drawCommitBullet"),Kr=h((e,r,t,o)=>{var s;if(r.type!==m.CHERRY_PICK&&(r.customId&&r.type===m.MERGE||r.type!==m.MERGE)&&C?.showCommitLabel){const c=e.append("g"),d=c.insert("rect").attr("class","commit-label-bkg"),l=c.append("text").attr("x",o).attr("y",t.y+25).attr("class","commit-label").text(r.id),f=(s=l.node())==null?void 0:s.getBBox();if(f&&(d.attr("x",t.posWithOffset-f.width/2-M).attr("y",t.y+13.5).attr("width",f.width+2*M).attr("height",f.height+2*M),y==="TB"||y==="BT"?(d.attr("x",t.x-(f.width+4*L+5)).attr("y",t.y-12),l.attr("x",t.x-(f.width+4*L)).attr("y",t.y+f.height-12)):l.attr("x",t.posWithOffset-f.width/2),C.rotateCommitLabel))if(y==="TB"||y==="BT")l.attr("transform","rotate(-45, "+t.x+", "+t.y+")"),d.attr("transform","rotate(-45, "+t.x+", "+t.y+")");else{const a=-7.5-(f.width+10)/25*9.5,n=10+f.width/25*8.5;c.attr("transform","translate("+a+", "+n+") rotate(-45, "+o+", "+t.y+")")}}},"drawCommitLabel"),Ur=h((e,r,t,o)=>{var s;if(r.tags.length>0){let c=0,d=0,l=0;const f=[];for(const a of r.tags.reverse()){const n=e.insert("polygon"),x=e.append("circle"),$=e.append("text").attr("y",t.y-16-c).attr("class","tag-label").text(a),g=(s=$.node())==null?void 0:s.getBBox();if(!g)throw new Error("Tag bbox not found");d=Math.max(d,g.width),l=Math.max(l,g.height),$.attr("x",t.posWithOffset-g.width/2),f.push({tag:$,hole:x,rect:n,yOffset:c}),c+=20}for(const{tag:a,hole:n,rect:x,yOffset:$}of f){const g=l/2,p=t.y-19.2-$;if(x.attr("class","tag-label-bkg").attr("points",`
      ${o-d/2-L/2},${p+M}  
      ${o-d/2-L/2},${p-M}
      ${t.posWithOffset-d/2-L},${p-g-M}
      ${t.posWithOffset+d/2+L},${p-g-M}
      ${t.posWithOffset+d/2+L},${p+g+M}
      ${t.posWithOffset-d/2-L},${p+g+M}`),n.attr("cy",p).attr("cx",o-d/2+L/2).attr("r",1.5).attr("class","tag-hole"),y==="TB"||y==="BT"){const u=o+$;x.attr("class","tag-label-bkg").attr("points",`
        ${t.x},${u+2}
        ${t.x},${u-2}
        ${t.x+G},${u-g-2}
        ${t.x+G+d+4},${u-g-2}
        ${t.x+G+d+4},${u+g+2}
        ${t.x+G},${u+g+2}`).attr("transform","translate(12,12) rotate(45, "+t.x+","+o+")"),n.attr("cx",t.x+L/2).attr("cy",u).attr("transform","translate(12,12) rotate(45, "+t.x+","+o+")"),a.attr("x",t.x+5).attr("y",u+3).attr("transform","translate(14,14) rotate(45, "+t.x+","+o+")")}}}},"drawCommitTags"),Vr=h(e=>{switch(e.customType??e.type){case m.NORMAL:return"commit-normal";case m.REVERSE:return"commit-reverse";case m.HIGHLIGHT:return"commit-highlight";case m.MERGE:return"commit-merge";case m.CHERRY_PICK:return"commit-cherry-pick";default:return"commit-normal"}},"getCommitClassType"),Xr=h((e,r,t,o)=>{const s={x:0,y:0};if(e.parents.length>0){const c=X(e.parents);if(c){const d=o.get(c)??s;return r==="TB"?d.y+_:r==="BT"?(o.get(e.id)??s).y-_:d.x+_}}else return r==="TB"?P:r==="BT"?(o.get(e.id)??s).y-_:0;return 0},"calculatePosition"),Jr=h((e,r,t)=>{var o,s;const c=y==="BT"&&t?r:r+G,d=y==="TB"||y==="BT"?c:(o=E.get(e.branch))==null?void 0:o.pos,l=y==="TB"||y==="BT"?(s=E.get(e.branch))==null?void 0:s.pos:c;if(l===void 0||d===void 0)throw new Error(`Position were undefined for commit ${e.id}`);return{x:l,y:d,posWithOffset:c}},"getCommitPosition"),W=h((e,r,t)=>{if(!C)throw new Error("GitGraph config not found");const o=e.append("g").attr("class","commit-bullets"),s=e.append("g").attr("class","commit-labels");let c=y==="TB"||y==="BT"?P:0;const d=[...r.keys()],l=C?.parallelCommits??!1,f=h((n,x)=>{var $,g;const p=($=r.get(n))==null?void 0:$.seq,u=(g=r.get(x))==null?void 0:g.seq;return p!==void 0&&u!==void 0?p-u:0},"sortKeys");let a=d.sort(f);y==="BT"&&(l&&Dr(a,r,c),a=a.reverse()),a.forEach(n=>{var x;const $=r.get(n);if(!$)throw new Error(`Commit not found for key ${n}`);l&&(c=Xr($,y,c,T));const g=Jr($,c,l);if(t){const p=Vr($),u=$.customType??$.type,k=((x=E.get($.branch))==null?void 0:x.index)??0;Yr(o,$,g,p,k,u),Kr(s,$,g,c),Ur(s,$,g,c)}y==="TB"||y==="BT"?T.set($.id,{x:g.x,y:g.posWithOffset}):T.set($.id,{x:g.posWithOffset,y:g.y}),c=y==="BT"&&l?c+_:c+_+G,c>R&&(R=c)})},"drawCommits"),Qr=h((e,r,t,o,s)=>{const d=(y==="TB"||y==="BT"?t.x<o.x:t.y<o.y)?r.branch:e.branch,l=h(a=>a.branch===d,"isOnBranchToGetCurve"),f=h(a=>a.seq>e.seq&&a.seq<r.seq,"isBetweenCommits");return[...s.values()].some(a=>f(a)&&l(a))},"shouldRerouteArrow"),H=h((e,r,t=0)=>{const o=e+Math.abs(e-r)/2;if(t>5)return o;if(z.every(d=>Math.abs(d-o)>=10))return z.push(o),o;const c=Math.abs(e-r);return H(e,r-c/5,t+1)},"findLane"),Zr=h((e,r,t,o)=>{var s,c,d,l,f;const a=T.get(r.id),n=T.get(t.id);if(a===void 0||n===void 0)throw new Error(`Commit positions not found for commits ${r.id} and ${t.id}`);const x=Qr(r,t,a,n,o);let $="",g="",p=0,u=0,k=(s=E.get(t.branch))==null?void 0:s.index;t.type===m.MERGE&&r.id!==t.parents[0]&&(k=(c=E.get(r.branch))==null?void 0:c.index);let b;if(x){$="A 10 10, 0, 0, 0,",g="A 10 10, 0, 0, 1,",p=10,u=10;const I=a.y<n.y?H(a.y,n.y):H(n.y,a.y),w=a.x<n.x?H(a.x,n.x):H(n.x,a.x);y==="TB"?a.x<n.x?b=`M ${a.x} ${a.y} L ${w-p} ${a.y} ${g} ${w} ${a.y+u} L ${w} ${n.y-p} ${$} ${w+u} ${n.y} L ${n.x} ${n.y}`:(k=(d=E.get(r.branch))==null?void 0:d.index,b=`M ${a.x} ${a.y} L ${w+p} ${a.y} ${$} ${w} ${a.y+u} L ${w} ${n.y-p} ${g} ${w-u} ${n.y} L ${n.x} ${n.y}`):y==="BT"?a.x<n.x?b=`M ${a.x} ${a.y} L ${w-p} ${a.y} ${$} ${w} ${a.y-u} L ${w} ${n.y+p} ${g} ${w+u} ${n.y} L ${n.x} ${n.y}`:(k=(l=E.get(r.branch))==null?void 0:l.index,b=`M ${a.x} ${a.y} L ${w+p} ${a.y} ${g} ${w} ${a.y-u} L ${w} ${n.y+p} ${$} ${w-u} ${n.y} L ${n.x} ${n.y}`):a.y<n.y?b=`M ${a.x} ${a.y} L ${a.x} ${I-p} ${$} ${a.x+u} ${I} L ${n.x-p} ${I} ${g} ${n.x} ${I+u} L ${n.x} ${n.y}`:(k=(f=E.get(r.branch))==null?void 0:f.index,b=`M ${a.x} ${a.y} L ${a.x} ${I+p} ${g} ${a.x+u} ${I} L ${n.x-p} ${I} ${$} ${n.x} ${I-u} L ${n.x} ${n.y}`)}else $="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",p=20,u=20,y==="TB"?(a.x<n.x&&(t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${a.x} ${n.y-p} ${$} ${a.x+u} ${n.y} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${n.x-p} ${a.y} ${g} ${n.x} ${a.y+u} L ${n.x} ${n.y}`),a.x>n.x&&($="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",p=20,u=20,t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${a.x} ${n.y-p} ${g} ${a.x-u} ${n.y} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${n.x+p} ${a.y} ${$} ${n.x} ${a.y+u} L ${n.x} ${n.y}`),a.x===n.x&&(b=`M ${a.x} ${a.y} L ${n.x} ${n.y}`)):y==="BT"?(a.x<n.x&&(t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${a.x} ${n.y+p} ${g} ${a.x+u} ${n.y} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${n.x-p} ${a.y} ${$} ${n.x} ${a.y-u} L ${n.x} ${n.y}`),a.x>n.x&&($="A 20 20, 0, 0, 0,",g="A 20 20, 0, 0, 1,",p=20,u=20,t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${a.x} ${n.y+p} ${$} ${a.x-u} ${n.y} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${n.x-p} ${a.y} ${$} ${n.x} ${a.y-u} L ${n.x} ${n.y}`),a.x===n.x&&(b=`M ${a.x} ${a.y} L ${n.x} ${n.y}`)):(a.y<n.y&&(t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${n.x-p} ${a.y} ${g} ${n.x} ${a.y+u} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${a.x} ${n.y-p} ${$} ${a.x+u} ${n.y} L ${n.x} ${n.y}`),a.y>n.y&&(t.type===m.MERGE&&r.id!==t.parents[0]?b=`M ${a.x} ${a.y} L ${n.x-p} ${a.y} ${$} ${n.x} ${a.y-u} L ${n.x} ${n.y}`:b=`M ${a.x} ${a.y} L ${a.x} ${n.y+p} ${g} ${a.x+u} ${n.y} L ${n.x} ${n.y}`),a.y===n.y&&(b=`M ${a.x} ${a.y} L ${n.x} ${n.y}`));if(b===void 0)throw new Error("Line definition not found");e.append("path").attr("d",b).attr("class","arrow arrow"+k%O)},"drawArrow"),re=h((e,r)=>{const t=e.append("g").attr("class","commit-arrows");[...r.keys()].forEach(o=>{const s=r.get(o);s.parents&&s.parents.length>0&&s.parents.forEach(c=>{Zr(t,r.get(c),s,r)})})},"drawArrows"),ee=h((e,r)=>{const t=e.append("g");r.forEach((o,s)=>{var c;const d=s%O,l=(c=E.get(o.name))==null?void 0:c.pos;if(l===void 0)throw new Error(`Position not found for branch ${o.name}`);const f=t.append("line");f.attr("x1",0),f.attr("y1",l),f.attr("x2",R),f.attr("y2",l),f.attr("class","branch branch"+d),y==="TB"?(f.attr("y1",P),f.attr("x1",l),f.attr("y2",R),f.attr("x2",l)):y==="BT"&&(f.attr("y1",R),f.attr("x1",l),f.attr("y2",P),f.attr("x2",l)),z.push(l);const a=o.name,n=V(a),x=t.insert("rect"),g=t.insert("g").attr("class","branchLabel").insert("g").attr("class","label branch-label"+d);g.node().appendChild(n);const p=n.getBBox();x.attr("class","branchLabelBkg label"+d).attr("rx",4).attr("ry",4).attr("x",-p.width-4-(C?.rotateCommitLabel===!0?30:0)).attr("y",-p.height/2+8).attr("width",p.width+18).attr("height",p.height+4),g.attr("transform","translate("+(-p.width-14-(C?.rotateCommitLabel===!0?30:0))+", "+(l-p.height/2-1)+")"),y==="TB"?(x.attr("x",l-p.width/2-10).attr("y",0),g.attr("transform","translate("+(l-p.width/2-5)+", 0)")):y==="BT"?(x.attr("x",l-p.width/2-10).attr("y",R),g.attr("transform","translate("+(l-p.width/2-5)+", "+R+")")):x.attr("transform","translate(-19, "+(l-p.height/2)+")")})},"drawBranches"),te=h(function(e,r,t,o,s){return E.set(e,{pos:r,index:t}),r+=50+(s?40:0)+(y==="TB"||y==="BT"?o.width/2:0),r},"setBranchPosition"),ae=h(function(e,r,t,o){if(zr(),v.debug("in gitgraph renderer",e+`
`,"id:",r,t),!C)throw new Error("GitGraph config not found");const s=C.rotateCommitLabel??!1,c=o.db;q=c.getCommits();const d=c.getBranchesAsObjArray();y=c.getDirection();const l=or(`[id="${r}"]`);let f=0;d.forEach((a,n)=>{var x;const $=V(a.name),g=l.append("g"),p=g.insert("g").attr("class","branchLabel"),u=p.insert("g").attr("class","label branch-label");(x=u.node())==null||x.appendChild($);const k=$.getBBox();f=te(a.name,f,n,k,s),u.remove(),p.remove(),g.remove()}),W(l,q,!1),C.showBranches&&ee(l,d),re(l,q),W(l,q,!0),cr.insertTitle(l,"gitTitleText",C.titleTopMargin??0,c.getDiagramTitle()),ir(void 0,l,C.diagramPadding,C.useMaxWidth)},"draw"),ne={draw:ae},se=h(e=>`
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0,1,2,3,4,5,6,7].map(r=>`
        .branch-label${r} { fill: ${e["gitBranchLabel"+r]}; }
        .commit${r} { stroke: ${e["git"+r]}; fill: ${e["git"+r]}; }
        .commit-highlight${r} { stroke: ${e["gitInv"+r]}; fill: ${e["gitInv"+r]}; }
        .label${r}  { fill: ${e["git"+r]}; }
        .arrow${r} { stroke: ${e["git"+r]}; }
        `).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`,"getStyles"),oe=se,bt={parser:Pr,db:U,renderer:ne,styles:oe};export{bt as diagram};
