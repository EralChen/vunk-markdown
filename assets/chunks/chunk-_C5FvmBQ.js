import{i6 as z,n as N,c3 as A,sF as O,ss as E,ts as U,tt as j,tu as G,tv as W,tw as Z,tx as K,ty as Y,lU as q,su as v,hc as x,qs as J,pT as w,d6 as P,s as Q,tz as X,tA as ee,dh as te,aJ as le,aP as se,sC as $,fR as ie,bX as ae,aC as k,df as ne,ai as d,aj as m,al as re}from"./chunk-DG8qAmac.js";import{p as oe,t as he}from"./chunk-BkIp0ebS.js";import{p as ce}from"./chunk-D7Zni-WX.js";import{l as ue}from"./chunk-D2UuGkPh.js";import{p as de}from"./chunk-iZBuNf_K.js";import"./chunk-DCcMeRAK.js";import"./chunk-CUzevAry.js";import"./chunk-CNWaEmyl.js";import"./chunk-DG055bIT.js";class ge{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,s=0;const l=this._shift+this.getLevelShift(e[0]);if(l){const r=(1<<l)-1,a=t/(this._scale*(1<<l-1));i=(e[2]&r)*a,s=(e[1]&r)*a}return[i,s]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}}class B extends oe{constructor(e,t,i,s){super(e,t,i,e.tileInfo.lods.length-1),this._memCache=s,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new he(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t){const i=new z(e[0],e[1],e[2],0);let s=this._memCache.get(i.id);if(s)return s.retain(),s;const l=await this._getVectorTileData(i);if(N(t),!this._layer)return null;if(s=this._memCache.get(i.id),s)return s.retain(),s;const r=this._layer.tileInfo.getTileBounds(A(),i),a=this._tileInfoView.getTileResolution(e[0]);return s=new O(i,a,r[0],r[3],E,E,this._styleRepository,this._memCache),s.setData(l),l&&(s.retain(),this._memCache.put(i.id,s,U)),s.neededForCoverage=!0,s.transforms.tileUnitsToPixels=j(1/8,0,0,0,1/8,0,0,0,1),s}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,s={signal:i.signal},l=this._getParsedVectorTileData(e,s).then((r=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),r))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,l),this._ongoingRequestToController.set(t,i),l}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}}const p={vtlBackground:W,vtlFill:Y,vtlLine:K,vtlCircle:Z,vtlSymbol:G},f=1e-6;class D{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new ce}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=q(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,t,i){const s=i.layers;e.renderPass="translucent";let l=this._brushCache.vtlSymbol;l==null&&(l=new p.vtlSymbol,this._brushCache.vtlSymbol=l),g[0]=t;for(let r=0;r<s.length;r++){const a=s[r];if(a.type!==v.SYMBOL)continue;const o=a.getLayoutProperty("visibility");if(o&&o.getValue()===x.NONE)continue;const h=e.displayLevel;a.minzoom!==void 0&&a.minzoom>h+f||a.maxzoom!==void 0&&a.maxzoom<=h-f||(e.styleLayerUID=a.uid,e.styleLayer=a,l.drawMany(e,g))}g[0]=null}drawBackground(e,t,i){if(i.backgroundBucketIds.length===0)return;const{context:s,displayLevel:l,requiredLevel:r}=e;t.key.level=r,s.setBlendingEnabled(!0),s.setDepthTestEnabled(!1),s.setStencilTestEnabled(!1),e.renderPass="background";let a=this._brushCache.vtlBackground;a==null&&(a=new p.vtlBackground,this._brushCache.vtlBackground=a),g[0]=t,i.backgroundBucketIds.forEach((o=>{const h=i.getLayerById(o);if(h.type!==v.BACKGROUND)return;const C=h.getLayoutProperty("visibility");C&&C.getValue()===x.NONE||h.minzoom!==void 0&&h.minzoom>l+f||h.maxzoom!==void 0&&h.maxzoom<=l-f||(e.styleLayerUID=h.uid,e.styleLayer=h,a.drawMany(e,g))})),g[0]=null}drawTile(e,t,i,s){const{context:l}=e,r=i.layers;l.setBlendingEnabled(!1),l.setDepthTestEnabled(!0),l.setDepthWriteEnabled(!0),l.setDepthFunction(J.LEQUAL);const a=r.filter((o=>s!=null&&s!==o.type||!t.layerData.has(o.uid)?!1:o.getLayoutProperty("visibility")?.getValue()!==x.NONE));e.renderPass="opaque";for(let o=a.length-1;o>=0;--o)this._renderStyleLayer(a[o],e,t);l.setDepthWriteEnabled(!1),l.setBlendingEnabled(!0),l.setBlendFunctionSeparate(w.ONE,w.ONE_MINUS_SRC_ALPHA,w.ONE,w.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent",a.forEach((o=>this._renderStyleLayer(o,e,t))),l.setDepthTestEnabled(!1),l.bindVAO()}_renderStyleLayer(e,t,i){const{renderPass:s}=t;let l;switch(e.type){case v.BACKGROUND:if(s!=="background")return;l=this._brushCache.vtlBackground,l||(l=new p.vtlBackground,this._brushCache.vtlBackground=l);break;case v.FILL:if(s!=="opaque"&&t.renderPass!=="translucent")return;l=this._brushCache.vtlFill,l==null&&(l=new p.vtlFill,this._brushCache.vtlFill=l);break;case v.LINE:if(s!=="translucent")return;l=this._brushCache.vtlLine,l==null&&(l=new p.vtlLine,this._brushCache.vtlLine=l);break;case v.CIRCLE:if(s!=="translucent")return;l=this._brushCache.vtlCircle,l==null&&(l=new p.vtlCircle,this._brushCache.vtlCircle=l);break;case v.SYMBOL:if(s!=="translucent")return;l=this._brushCache.vtlSymbol,l==null&&(l=new p.vtlSymbol,this._brushCache.vtlSymbol=l)}const{displayLevel:r}=t,{minzoom:a,maxzoom:o}=e;if(a!==void 0&&a>r+f||o!==void 0&&o<=r-f)return;const{context:h}=t;h.setStencilTestEnabled(!1),h.setStencilWriteMask(0),t.styleLayerUID=e.uid,t.styleLayer=e,g[0]=i,l.drawMany(t,g),g[0]=null}}const g=[null];let c=class extends de(ue(ne)){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=P("disable-feature:vtl-level-shift")?0:1}initialize(){if(this.layer.fullExtent==null)return void this.addResolvingPromise(Promise.reject(new Q("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:n,spatialReference:e,state:t,viewingMode:i}=this.view,s=i==="local"&&!X(e)||ee.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),l=this._getTileInfoSupportError(s,this.layer.fullExtent);if(l!=null)return this.addResolvingPromise(Promise.reject(l));const r=te((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const u=n.tilingScheme,y=u.pixelSize,T=y===256?1:2,_=n.spatialReference?.isGeographic&&y===256?1:0,S=n.spatialReference?.isGeographic||y!==256?0:1;let b;this.schemaHelper=new ge(T,_,this.levelShift+S),b=y===256||y===512?this.layer.tileInfo.getCompatibleForVTL(y):this.layer.tileInfo;const L=this._getTileInfoCompatibilityError(b,u);if(L)throw L;this.tileInfo=b}));this._tileHandlerController=new AbortController;const a=this.view.resourceController;this._memCache=a.memoryController.newCache(`vtl-${this.layer.uid}`,(u=>u.release())),this.addHandles(le((()=>this.view.qualitySettings.memoryLimit),(u=>this._memCache.maxSize=Math.ceil(u/10*1048576)),se));const o=new $(this.layer.currentStyleInfo.style);this._tileHandler=new B(this.layer,o,t.contentPixelRatio,this._memCache);const h=this._tileHandlerController.signal,C=ye(a),M=this._tileHandler.start({signal:h,schedule:C}),H=this._tileHandler.spriteMosaic;H.then((u=>{!ie(h)&&this._tileHandler&&(this.painter=new D(u,this._tileHandler.glyphMosaic))})),M.then((()=>this._tileHandlerController=null));const R=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const u=this.layer.currentStyleInfo.style,y=this.view.state?.contentPixelRatio??1,T=new $(u),_=new B(this.layer,T,y,this._memCache),S=_.start({signal:this._tileHandlerController.signal,schedule:C}),b=_.spriteMosaic;S.then((()=>this._tileHandlerController=null)),this._updatingHandles.addPromise(Promise.all([S,b]).then((([,L])=>{const F=this._tileHandler,I=this.painter;this.painter=new D(L,_.glyphMosaic),this._tileHandler=_,this.emit("data-changed"),F.destroy(),I&&I.dispose()})))};this._updatingHandles.add((()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio})),R),this.addHandles([this.layer.on("paint-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-change",R),this.layer.on("delete-style-layer",R),this.layer.on("spriteSource-change",(()=>this.emit("data-changed"))),this.layer.on("layout-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-visibility-change",(()=>this.emit("data-changed")))]);const V=Promise.all([r,M,H]);this.addResolvingPromise(V)}destroy(){this.painter=q(this.painter),this._tileHandlerController=ae(this._tileHandlerController),this._tileHandler=k(this._tileHandler),this._memCache=k(this._memCache)}get contentZoom(){return P("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const n=this.tileInfo.lods,e=this.layer.minScale||n[0].scale,t=this.layer.maxScale||n[n.length-1].scale,i=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale?i.maxLevel++:i.maxLevel+=this.levelShift,i}get dataScaleRange(){const n=this.tileInfo.lods;return{minScale:n[0].scale,maxScale:n[n.length-1].scale}}get dataLevelRange(){const{minScale:n,maxScale:e}=this.dataScaleRange,t=this.levelRangeFromScaleRange(n,e);return t.minLevel===1&&this.tileInfo.size[0]===256&&(t.minLevel=0),t.maxLevel+=this.levelShift,t}async fetchTile(n,e){const t=this.schemaHelper.getLevelRowColumn(n);return this._tileHandler.getVectorTile(t,e)}get hasVisibleFeatures(){return!0}};d([m()],c.prototype,"layer",void 0),d([m()],c.prototype,"levelShift",void 0),d([m()],c.prototype,"contentZoom",null),d([m()],c.prototype,"displayLevelRange",null),d([m()],c.prototype,"tileInfo",void 0),d([m()],c.prototype,"dataScaleRange",null),d([m()],c.prototype,"dataLevelRange",null),d([m()],c.prototype,"updatingProgressValue",void 0),c=d([re("esri.views.3d.layers.VectorTileLayerView3D")],c);const we=c;function ye(n){return e=>n.immediate.schedule(e)}export{we as default};
