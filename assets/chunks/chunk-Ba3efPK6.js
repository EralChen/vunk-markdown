import{K as l,R as f,gO as y,H as S,eF as c,gW as s,gV as g,B as R,lS as d,gS as O,lT as x}from"./chunk-CuaFhuP3.js";import"./chunk-Dpk1TJd9.js";import"./chunk-iOPJXyP1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DGmg3LSc.js";function J(r){const i=r.geometry,e=r.toJSON(),t=e;let m,o,n;if(i!=null&&(o=i.spatialReference,n=s(o),t.geometryType=g(i),t.geometry=JSON.stringify(i),t.inSR=n),e.outSR?(t.outSR=s(e.outSR),m=r.outSpatialReference):i&&(t.outSR=t.inSR,m=o),t.bin&&=JSON.stringify(t.bin),t.quantizationParameters&&=JSON.stringify(t.quantizationParameters),t.outStatistics&&=JSON.stringify(t.outStatistics),t.outTimeReference&&=JSON.stringify(t.outTimeReference),e.timeExtent){const p=e.timeExtent,{start:a,end:u}=p;a==null&&u==null||(t.time=a===u?a:`${a??"null"},${u??"null"}`),delete e.timeExtent}return r.defaultSpatialReference&&R(o,m)&&(t.defaultSR=t.inSR,delete t.inSR,delete t.outSR),t}async function N(r,i,e){return i.timeExtent!=null&&i.timeExtent.isEmpty?{data:{features:[]}}:await q(r,i,e)}async function q(r,i,e={}){const t=typeof r=="string"?l(r):r,m=i.geometry?[i.geometry]:[],o=await f(m,null,{signal:e.signal}),n=o?.[0];n!=null&&((i=i.clone()).geometry=n);const p=y({...t.query,f:"json",...J(i)});return S(c(t.path,"queryBins"),{...e,query:{...p,...e.query}})}async function st(r,i,e){const{data:t}=await N(O(r),d.from(i),e);return x.fromJSON(t)}export{st as executeAttributeBinsQuery};
