import{S as u}from"./chunk-Dpk1TJd9.js";import{t as a,s as c}from"./chunk-B92kdZ15.js";import{j as f}from"./chunk-BUVSeX7E.js";import{getSpatialReference as n,toGeometry as p,fromGeometry as s}from"./chunk-qOGZTybA.js";import"./chunk-iOPJXyP1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-Da9IW-EP.js";import"./chunk-A9ItisFv.js";import"./chunk-RvJNgVq9.js";import"./chunk-CuaFhuP3.js";import"./chunk-DGmg3LSc.js";import"./chunk-DP7_WWTp.js";import"./chunk-BoBj9ZcI.js";class l{getOperatorType(){return 10303}supportsCurves(){return!0}accelerateGeometry(t,r,e){return!1}canAccelerateGeometry(t){return!1}executeMany(t,r,e){return new y(t,r,e)}execute(t,r,e){const m=t.clone();return m.applyTransformation(r),m}}class y extends a{constructor(t,r,e){super(),this.m_index=-1,this.m_transformation=r.clone(),this.m_inputGeometryCursor=t}next(){let t;if(t=this.m_inputGeometryCursor.next()){f(t),this.m_index=this.m_inputGeometryCursor.getGeometryID();const r=t.clone();return r.applyTransformation(this.m_transformation),r}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}const i=new l;function x(o,t){return i.execute(o,t,null)}function G(o,t){const r=i.executeMany(new c(o),t,null);return Array.from(r)}function h(){return i.supportsCurves()}function ft(o,t){const r=n(o);return p(x(s(o),t.transform),r)}function lt(o,t){const r=o.map(s),e=n(o);return G(r,t.transform).map((m=>p(m,e))).filter(u)}const yt=h();export{ft as execute,lt as executeMany,yt as supportsCurves};
