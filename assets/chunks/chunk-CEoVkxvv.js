import{a3 as I,a4 as L,B as Y,a5 as q,a6 as z,a7 as F,a8 as v,a9 as H,aa as J,ab as K,ac as w}from"./chunk-DNeauRff.js";import{al as P,g as O}from"./chunk-CeTJQyzn.js";import{g as Q}from"./chunk-YqgWiO-_.js";function T(t){return X(t)}function m(t){return t.assignedSlot?t.assignedSlot:t.parentNode instanceof ShadowRoot?t.parentNode.host:t.parentNode}function X(t){for(let e=t;e;e=m(e))if(e instanceof Element&&getComputedStyle(e).display==="none")return null;for(let e=m(t);e;e=m(e)){if(!(e instanceof Element))continue;const n=getComputedStyle(e);if(n.display!=="contents"&&(n.position!=="static"||I(n)||e.tagName==="BODY"))return e}return null}/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.1.0 */(function(){if(O()){const t=w.getOffsetParent;w.getOffsetParent=e=>t(e,T)}})();function x(t){const e=window.devicePixelRatio||1;return Math.round(t*e)/e}const $=async(t,{referenceEl:e,floatingEl:n,overlayPositioning:a="absolute",placement:o,flipDisabled:s,flipPlacements:l,offsetDistance:i,offsetSkidding:p,arrowEl:d,type:M})=>{if(!e||!n)return;const y=Q(n)==="rtl",{x:A,y:C,placement:b,strategy:N,middlewareData:g}=await q(e,n,{strategy:a,placement:o==="auto"||o==="auto-start"||o==="auto-end"?void 0:S(o,y),middleware:V({placement:o,flipDisabled:s,flipPlacements:l?.map(f=>S(f,y)),offsetDistance:i,offsetSkidding:p,arrowEl:d,type:M})});if(d&&g.arrow){const{x:f,y:B}=g.arrow,c=b.split("-")[0],E=f!=null?"left":"top",R=_[c],W={left:"",top:"",bottom:"",right:""};"floatingLayout"in t&&(t.floatingLayout=c==="left"||c==="right"?"horizontal":"vertical"),Object.assign(d.style,{...W,[E]:`${E=="left"?f:B}px`,[c]:"100%",transform:R})}const h=g.hide?.referenceHidden?"hidden":null,U=h?"none":null;n.setAttribute(G,b),Object.assign(n.style,{pointerEvents:U,position:N,transform:`translate(${x(A)}px,${x(C)}px)`,visibility:h})},G="data-placement",k=["top","bottom","right","left","top-start","top-end","bottom-start","bottom-end","right-start","right-end","left-start","left-end","leading","trailing","leading-start","leading-end","trailing-start","trailing-end"],it="bottom-start",st="bottom-end",lt={animation:"calcite-floating-ui-anim",animationActive:"calcite-floating-ui-anim--active"};function V({placement:t,flipDisabled:e,flipPlacements:n,offsetDistance:a,offsetSkidding:o,arrowEl:s,type:l}){const i=[z(),F()];return l==="menu"&&i.push(v({fallbackPlacements:n||["top-start","top","top-end","bottom-start","bottom","bottom-end"]})),i.push(H({mainAxis:typeof a=="number"?a:0,crossAxis:typeof o=="number"?o:0})),t==="auto"||t==="auto-start"||t==="auto-end"?i.push(J({alignment:t==="auto-start"?"start":t==="auto-end"?"end":null})):e||i.push(v(n?{fallbackPlacements:n}:{})),s&&i.push(K({element:s})),i}function rt(t,e){const n=t.filter(a=>k.includes(a));return n.length!==t.length&&console.warn(`${e.tagName}: Invalid value found in: flipPlacements. Try any of these: ${k.map(a=>`"${a}"`).join(", ").trim()}`,{el:e}),n}function S(t,e=!1){const n=["left","right"];return e&&n.reverse(),t.replace(/leading/gi,n[0]).replace(/trailing/gi,n[1])}async function ft(t,e,n=!1){if(!(!t.open||!e.floatingEl||!e.referenceEl)){if(Object.assign(e.floatingEl.style,{display:"block",position:e.overlayPositioning??"absolute"}),!r.get(t))return j(t);await(n?Z(t):$)(t,e)}}function Z(t){let e=u.get(t);return e||(e=Y($,P.reposition,{leading:!0,maxWait:P.reposition}),u.set(t,e),e)}const _={top:"",left:"rotate(-90deg)",bottom:"rotate(180deg)",right:"rotate(90deg)"},r=new WeakMap,u=new WeakMap;async function j(t){const{referenceEl:e,floatingEl:n}=t;if(!n.isConnected)return;const a=O()?L:(l,i,p)=>(p(),()=>{});r.set(t,{state:"pending"});let o;const s=a(e,n,()=>{const l=t.reposition();o||(o=l)});return r.set(t,{state:"active",cleanUp:s}),o}function tt(t){const{floatingEl:e}=t;e&&Object.assign(e.style,{display:"",pointerEvents:"",position:"",transform:"",visibility:""})}async function ct(t){const{floatingEl:e,referenceEl:n}=t;if(tt(t),!(!e||!n)&&(et(t),!!t.open))return j(t)}function et(t){const{floatingEl:e,referenceEl:n}=t;if(!e||!n)return;const a=r.get(t);a?.state==="active"&&a.cleanUp(),r.delete(t),u.get(t)?.cancel(),u.delete(t)}const D=4,ut=Math.ceil(Math.hypot(D,D));export{tt as X,et as Y,ct as c,ft as f,rt as l,it as o,lt as r,st as s,ut as u};
