import{h0 as v,G as d,bc as h,h1 as g,d3 as M,h2 as c,h3 as y,h4 as I,h5 as w,h6 as S}from"./chunk-B93eA3hr.js";import{u as $,c as l,i as x,f as F}from"./chunk-BoUT8An0.js";import"./chunk-DB56luzt.js";import"./chunk-CjSkIgyx.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-SqlbPPT2.js";import"./chunk-Bm5pF_uE.js";class O{transform(t){const r=this._transform(t),o=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&o.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&v(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&o.push(n.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(t){const r=$(t.schema,t.geometryBuffer);let o=r.length/3,n=null;const f=new Array,a=l(t.primaryAttributeData,r,o);t.primaryAttributeData!=null&&a&&f.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:a});const u=l(t.modulationAttributeData,r,o);t.modulationAttributeData!=null&&u&&f.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:u});let i=x(t.rendererInfo,a,u,o);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const m=t.filterAttributesData.filter(d).map(e=>{const D=l(e,r,o),b={attributeInfo:e.attributeInfo,values:D};return f.push(b),b});n=new Uint32Array(o),o=F(r,i,n,t.filterInfo,m)}for(const m of t.userAttributesData){const e=l(m,r,o);f.push({attributeInfo:m.attributeInfo,values:e})}3*o<i.length&&(i=new Uint8Array(i.buffer.slice(0,3*o))),G(r,o,t.elevationOffset);const p=z(r,o,g.fromData(t.obbData),h.fromJSON(t.inSR),h.fromJSON(t.outSR));return{obbData:t.obbData,points:p,rgb:i,attributes:f,pointIdFilterMap:n}}}function z(s,t,r,o,n){if(!M(s,o,0,s,n,0,t))throw new Error("Can't reproject");const f=c(r.center),a=I(),u=I(),i=c(r.halfSize);y(A,r.quaternion);const p=new Float32Array(3*t);for(let m=0;m<t;m++){let e=3*m;a[0]=s[e]-f[0],a[1]=s[e+1]-f[1],a[2]=s[e+2]-f[2],w(u,a,A),i[0]=Math.max(i[0],Math.abs(u[0])),i[1]=Math.max(i[1],Math.abs(u[1])),i[2]=Math.max(i[2],Math.abs(u[2])),p[e++]=a[0],p[e++]=a[1],p[e]=a[2]}return r.halfSize=i,p}function G(s,t,r){if(r!==0)for(let o=0;o<t;o++)s[3*o+2]+=r}const A=S();function dt(){return new O}export{dt as default};
