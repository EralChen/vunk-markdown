import{dq as h,dr as H,s as y,c as $,bu as g,p as F,bv as M,ds as P,g as G}from"./chunk-CuaFhuP3.js";import{t as I,n as k}from"./chunk-YMP1s-Ms.js";import{o as x,u as D,s as d,l as C,e as b,y as A,c as v,i as E,a as f}from"./chunk-UaDW9Epa.js";import"./chunk-Dpk1TJd9.js";import"./chunk-iOPJXyP1.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DGmg3LSc.js";async function Oe(t,o){const r=t.instance.portalItem;if(r?.id)return await r.load(o),j(t),t.validateItem&&t.validateItem(r),O(t,o)}function j(t){const o=t.instance.portalItem;if(!o?.type||!t.supportedTypes.includes(o.type))throw new y("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:o?.type,expectedType:t.supportedTypes.join(", ")})}async function O(t,o){const r=t.instance,e=r.portalItem;if(!e)return;let{url:n}=e;const{title:a}=e,s=h(e,"portal-item");if(r.type==="group")return R(r,s,t);n&&r.type!=="media"&&r.read({url:n},s);const l=new b,{data:p,preferredHost:i}=await L(t,l,o);return n=e.url,"isUrlHostModified"in r&&(i?r.applyPreferredHost({preferredHost:i}):r.applyHostFromPortalItem()),p&&r.read(p,s),r.resourceReferences={portalItem:e,paths:s.readResourcePaths??[]},r.type!=="subtype-group"&&r.read({title:a},s),H(r,s)}async function R(t,o,r){const e=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:n,type:a}=e;if(a==="Group Layer"){if(!$(e,"Map"))throw new y("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return J(t,r)}return t.read({title:n},o),N(t,r)}async function J(t,o){const r=t.portalItem,e=await r.fetchData("json");if(!e)return;if(!o.populateGroupLayer)throw new y("portal:missing-populate-group-layer","Missing populate group layer");const n=h(r,"web-map");t.read(e,n),await o.populateGroupLayer(t,e,{context:n}),t.resourceReferences={portalItem:r,paths:n.readResourcePaths??[]}}async function N(t,o){let r;const{portalItem:e}=t;if(!e)return;const n=e.type,a=o.layerModuleTypeMap;if(!a)throw new y("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(n){case"Feature Service":case"Feature Collection":r=a.FeatureLayer;break;case"Stream Service":r=a.StreamLayer;break;case"Scene Service":r=a.SceneLayer;break;case"Video Service":r=a.VideoLayer;break;default:throw new y("portal:unsupported-item-type-as-group",`The item type '${n}' is not supported as a 'IGroupLayer'`)}const s=n==="Video Service",l=new b;let[p,{data:i}]=await Promise.all([r(),s?{data:null}:L(o,l)]),u=()=>p;if(s)return q(t,u,a);if(n==="Feature Service"){const c=d(i)?.customParameters;i=e.url?(await C(i,e.url,l)).data:{},u=await W(i,a)||u;const{provider:S,preferredHost:T}=await Q(e.url,{customParameters:c,loadContext:l});return g(e,T),await m(t,u,u,i,a,S)}return n==="Scene Service"&&e.url&&(i=await A(e,i,l)),v(i)>0?await m(t,u,null,i,a):await V(t,u,a)}async function V(t,o,r){const{portalItem:e}=t;if(!e?.url)return;const n=await I(e.url);n&&m(t,o,null,{layers:n.layers?.map(f),tables:n.tables?.map(f)},r)}async function q(t,o,r){const{portalItem:e}=t;if(!e?.url)return;const n=await I(e.url);n&&m(t,o,null,{layers:n.layers?.map((({id:a,name:s})=>({id:a,name:s})))},r)}async function m(t,o,r,e,n,a){let s=e.layers||[];const l=e.tables||[];if(t.portalItem?.type==="Feature Collection"?(s.forEach(((p,i)=>{p.id=i,p?.layerDefinition?.type==="Table"&&l.push(p)})),s=s.filter((p=>p?.layerDefinition?.type!=="Table"))):(s.reverse(),l.reverse()),s.forEach((p=>{const i=a?.(p);if(i||!a){const u=w(t,o(p),e,p,i);t.add(u)}})),l.length){const p=r?null:await n.FeatureLayer();l.forEach((i=>{const u=a?.(i);if(u||!a){const c=w(t,r?r(i):p,e,i,u);t.tables.add(c)}}))}}function w(t,o,r,e,n){const a=t.portalItem,s={portalItem:a.clone(),layerId:e.id};e.url!=null&&(s.url=e.url);const l=new o(s);if("sourceJSON"in l&&(l.sourceJSON=n),l.type!=="subtype-group"&&l.type!=="catalog"&&(l.sublayerTitleMode="service-name"),a.type==="Feature Collection"){const p={origin:"portal-item",portal:a.portal||G.getDefault()};l.read(e,p);const i=r.showLegend;i!=null&&l.read({showLegend:i},p)}return l}async function L(t,o,r){if(t.supportsData===!1)return{data:void 0};const e=t.instance,n=e.portalItem;if(!n)return{data:void 0};let a=null;try{a=await n.fetchData("json",r)}catch{}if(B(e)){let s=null;const{count:l,preferredHost:p}=await U(n,a,o);if(g(n,p),(a?.layers||a?.tables)&&l>0){if(e.layerId==null){const i=x(e.type),u=i?.length?D(a,i)[0]:d(a);u&&(e.layerId=u.id)}s=z(a,e),s?.layerType==="OrientedImageryLayer"&&e.type==="oriented-imagery"&&e.supportedSourceTypes.add("Feature Layer"),s&&a.showLegend!=null&&(s.showLegend=a.showLegend)}return l>1&&"sublayerTitleMode"in e&&e.sublayerTitleMode!=="service-name"&&(e.sublayerTitleMode="item-title-and-service-name"),{data:s,preferredHost:p}}return{data:a}}async function U(t,o,r){if(o?.layers&&o?.tables)return{count:v(o)};const e=F(t.url);if(!e)return{count:1};const n=e.url.path,a=await r.fetchServiceMetadata(n,{customParameters:d(o)?.customParameters}).catch((()=>null));return{count:(o?.layers?.length??a?.layers?.length??0)+(o?.tables?.length??a?.tables?.length??0),preferredHost:P(t)?M():null}}function z(t,o){const{layerId:r}=o,e=t.layers?.find((n=>n.id===r))||t.tables?.find((n=>n.id===r));return e&&K(e,o)?e:null}function B(t){return t.type!=="stream"&&"layerId"in t}function K(t,o){const r="layerType"in t&&t.layerType,{type:e}=o;return!(e==="feature"&&r&&t.layerType!=="ArcGISFeatureLayer"||e==="catalog"&&!r||e==="oriented-imagery"&&!r||e==="subtype-group"&&!r)}async function Q(t,o){const{layersJSON:r,preferredHost:e}=await k(t,o);if(!r)return{provider:null,preferredHost:e};const n=[...r.layers,...r.tables];return{provider:a=>n.find((s=>s.id===a.id)),preferredHost:e}}async function W(t,o){const{layers:r,tables:e}=t,n=[...r??[],...e??[]];if(!n.length)return;const a=new Set,s=[];for(const{layerType:i}of n){const u=i??"ArcGISFeatureLayer";if(a.has(u))continue;a.add(u);const c=o[E(u)];s.push(c())}const l=await Promise.all(s),p=new Map;return Array.from(a).forEach(((i,u)=>{p.set(i,l[u])})),({layerType:i})=>{const u=i??"ArcGISFeatureLayer";return p.get(u)}}export{Oe as load};
